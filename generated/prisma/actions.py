# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Client
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class StatusMasterActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.StatusMaster]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await StatusMaster.prisma().query_raw(
            'SELECT * FROM StatusMaster WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.StatusMaster
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await StatusMaster.prisma().query_first(
            'SELECT * FROM StatusMaster WHERE statusCode = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.StatusMasterCreateInput,
        include: Optional[types.StatusMasterInclude] = None
    ) -> _PrismaModelT:
        """Create a new StatusMaster record.

        Parameters
        ----------
        data
            StatusMaster record data
        include
            Specifies which relations should be loaded on the returned StatusMaster model

        Returns
        -------
        prisma.models.StatusMaster
            The created StatusMaster record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a StatusMaster record from just the required fields
        statusmaster = await StatusMaster.prisma().create(
            data={
                # data to create a StatusMaster record
                'statusCode': 'ggciceaie',
                'statusName': 'bbehjachib',
                'entityType': 'cadfabfehe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.StatusMasterCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple StatusMaster records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of StatusMaster record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await StatusMaster.prisma().create_many(
            data=[
                {
                    # data to create a StatusMaster record
                    'statusCode': 'dgiiaaijj',
                    'statusName': 'bfaiacjjfc',
                    'entityType': 'eigcfgbif',
                },
                {
                    # data to create a StatusMaster record
                    'statusCode': 'bagcfbhiig',
                    'statusName': 'cghideieh',
                    'entityType': 'biabhbdai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.StatusMasterWhereUniqueInput,
        include: Optional[types.StatusMasterInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single StatusMaster record.

        Parameters
        ----------
        where
            StatusMaster filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned StatusMaster model

        Returns
        -------
        prisma.models.StatusMaster
            The deleted StatusMaster record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        statusmaster = await StatusMaster.prisma().delete(
            where={
                'id': 'idghgaicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.StatusMasterWhereUniqueInput,
        include: Optional[types.StatusMasterInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique StatusMaster record.

        Parameters
        ----------
        where
            StatusMaster filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StatusMaster model

        Returns
        -------
        prisma.models.StatusMaster
            The found StatusMaster record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        statusmaster = await StatusMaster.prisma().find_unique(
            where={
                'id': 'fjfddhigg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.StatusMasterWhereUniqueInput,
        include: Optional[types.StatusMasterInclude] = None
    ) -> _PrismaModelT:
        """Find a unique StatusMaster record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            StatusMaster filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StatusMaster model

        Returns
        -------
        prisma.models.StatusMaster
            The found StatusMaster record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        statusmaster = await StatusMaster.prisma().find_unique_or_raise(
            where={
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StatusMasterWhereInput] = None,
        cursor: Optional[types.StatusMasterWhereUniqueInput] = None,
        include: Optional[types.StatusMasterInclude] = None,
        order: Optional[Union[types.StatusMasterOrderByInput, List[types.StatusMasterOrderByInput]]] = None,
        distinct: Optional[List[types.StatusMasterScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple StatusMaster records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of StatusMaster records returned
        skip
            Ignore the first N results
        where
            StatusMaster filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StatusMaster model
        order
            Order the returned StatusMaster records by any field
        distinct
            Filter StatusMaster records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.StatusMaster]
            The list of all StatusMaster records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 StatusMaster records
        statusmasters = await StatusMaster.prisma().find_many(take=10)

        # find the first 5 StatusMaster records ordered by the statusName field
        statusmasters = await StatusMaster.prisma().find_many(
            take=5,
            order={
                'statusName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StatusMasterWhereInput] = None,
        cursor: Optional[types.StatusMasterWhereUniqueInput] = None,
        include: Optional[types.StatusMasterInclude] = None,
        order: Optional[Union[types.StatusMasterOrderByInput, List[types.StatusMasterOrderByInput]]] = None,
        distinct: Optional[List[types.StatusMasterScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single StatusMaster record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StatusMaster filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StatusMaster model
        order
            Order the returned StatusMaster records by any field
        distinct
            Filter StatusMaster records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StatusMaster
            The first StatusMaster record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StatusMaster record ordered by the description field
        statusmaster = await StatusMaster.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StatusMasterWhereInput] = None,
        cursor: Optional[types.StatusMasterWhereUniqueInput] = None,
        include: Optional[types.StatusMasterInclude] = None,
        order: Optional[Union[types.StatusMasterOrderByInput, List[types.StatusMasterOrderByInput]]] = None,
        distinct: Optional[List[types.StatusMasterScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single StatusMaster record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StatusMaster filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StatusMaster model
        order
            Order the returned StatusMaster records by any field
        distinct
            Filter StatusMaster records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StatusMaster
            The first StatusMaster record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StatusMaster record ordered by the entityType field
        statusmaster = await StatusMaster.prisma().find_first_or_raise(
            skip=1,
            order={
                'entityType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.StatusMasterUpdateInput,
        where: types.StatusMasterWhereUniqueInput,
        include: Optional[types.StatusMasterInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single StatusMaster record.

        Parameters
        ----------
        data
            StatusMaster record data specifying what to update
        where
            StatusMaster filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned StatusMaster model

        Returns
        -------
        prisma.models.StatusMaster
            The updated StatusMaster record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        statusmaster = await StatusMaster.prisma().update(
            where={
                'id': 'cbbbjbfcii',
            },
            data={
                # data to update the StatusMaster record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.StatusMasterWhereUniqueInput,
        data: types.StatusMasterUpsertInput,
        include: Optional[types.StatusMasterInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            StatusMaster filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned StatusMaster model

        Returns
        -------
        prisma.models.StatusMaster
            The created or updated StatusMaster record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        statusmaster = await StatusMaster.prisma().upsert(
            where={
                'id': 'bbejhfidcb',
            },
            data={
                'create': {
                    'id': 'bbejhfidcb',
                    'statusCode': 'bagcfbhiig',
                    'statusName': 'cghideieh',
                    'entityType': 'biabhbdai',
                },
                'update': {
                    'statusCode': 'bagcfbhiig',
                    'statusName': 'cghideieh',
                    'entityType': 'biabhbdai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.StatusMasterUpdateManyMutationInput,
        where: types.StatusMasterWhereInput,
    ) -> int:
        """Update multiple StatusMaster records

        Parameters
        ----------
        data
            StatusMaster data to update the selected StatusMaster records to
        where
            Filter to select the StatusMaster records to update

        Returns
        -------
        int
            The total number of StatusMaster records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all StatusMaster records
        total = await StatusMaster.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StatusMasterWhereInput] = None,
        cursor: Optional[types.StatusMasterWhereUniqueInput] = None,
    ) -> int:
        """Count the number of StatusMaster records present in the database

        Parameters
        ----------
        select
            Select the StatusMaster fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StatusMaster filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StatusMasterCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StatusMaster.prisma().count()

        # results: prisma.types.StatusMasterCountAggregateOutput
        results = await StatusMaster.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.StatusMasterCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StatusMasterWhereInput] = None,
        cursor: Optional[types.StatusMasterWhereUniqueInput] = None,
    ) -> types.StatusMasterCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.StatusMasterCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StatusMasterWhereInput] = None,
        cursor: Optional[types.StatusMasterWhereUniqueInput] = None,
    ) -> Union[int, types.StatusMasterCountAggregateOutput]:
        """Count the number of StatusMaster records present in the database

        Parameters
        ----------
        select
            Select the StatusMaster fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StatusMaster filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StatusMasterCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StatusMaster.prisma().count()

        # results: prisma.types.StatusMasterCountAggregateOutput
        results = await StatusMaster.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.StatusMasterCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.StatusMasterWhereInput] = None
    ) -> int:
        """Delete multiple StatusMaster records.

        Parameters
        ----------
        where
            Optional StatusMaster filter to find the records to be deleted

        Returns
        -------
        int
            The total number of StatusMaster records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all StatusMaster records
        total = await StatusMaster.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.StatusMasterScalarFieldKeys'],
        *,
        where: Optional['types.StatusMasterWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.StatusMasterAvgAggregateInput'] = None,
        sum: Optional['types.StatusMasterSumAggregateInput'] = None,
        min: Optional['types.StatusMasterMinAggregateInput'] = None,
        max: Optional['types.StatusMasterMaxAggregateInput'] = None,
        having: Optional['types.StatusMasterScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.StatusMasterCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.StatusMasterScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.StatusMasterScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.StatusMasterGroupByOutput']:
        """Group StatusMaster records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar StatusMaster fields to group records by
        where
            StatusMaster filter to select records
        take
            Limit the maximum number of StatusMaster records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.StatusMasterGroupByOutput]
            A list of dictionaries representing the StatusMaster record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group StatusMaster records by updatedBy values
        # and count how many records are in each group
        results = await StatusMaster.prisma().group_by(
            ['updatedBy'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DesignationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Designation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Designation.prisma().query_raw(
            'SELECT * FROM Designation WHERE id = $1',
            'bgeecijdgg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Designation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Designation.prisma().query_first(
            'SELECT * FROM Designation WHERE designationName = $1',
            'bdiicjafbj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DesignationCreateInput,
        include: Optional[types.DesignationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Designation record.

        Parameters
        ----------
        data
            Designation record data
        include
            Specifies which relations should be loaded on the returned Designation model

        Returns
        -------
        prisma.models.Designation
            The created Designation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Designation record from just the required fields
        designation = await Designation.prisma().create(
            data={
                # data to create a Designation record
                'designationName': 'bgehebiafc',
                'designationCode': 'bghffegacj',
                'level': 1767274722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DesignationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Designation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Designation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Designation.prisma().create_many(
            data=[
                {
                    # data to create a Designation record
                    'designationName': 'dcgchcbbf',
                    'designationCode': 'bdedcabahc',
                    'level': 675780521,
                },
                {
                    # data to create a Designation record
                    'designationName': 'heejgedji',
                    'designationCode': 'bjgjgibgbf',
                    'level': 1116175964,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DesignationWhereUniqueInput,
        include: Optional[types.DesignationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Designation record.

        Parameters
        ----------
        where
            Designation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Designation model

        Returns
        -------
        prisma.models.Designation
            The deleted Designation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        designation = await Designation.prisma().delete(
            where={
                'id': 'igbehcbab',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DesignationWhereUniqueInput,
        include: Optional[types.DesignationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Designation record.

        Parameters
        ----------
        where
            Designation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Designation model

        Returns
        -------
        prisma.models.Designation
            The found Designation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        designation = await Designation.prisma().find_unique(
            where={
                'id': 'bdadaadhag',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DesignationWhereUniqueInput,
        include: Optional[types.DesignationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Designation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Designation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Designation model

        Returns
        -------
        prisma.models.Designation
            The found Designation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        designation = await Designation.prisma().find_unique_or_raise(
            where={
                'id': 'bgiggdidbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DesignationWhereInput] = None,
        cursor: Optional[types.DesignationWhereUniqueInput] = None,
        include: Optional[types.DesignationInclude] = None,
        order: Optional[Union[types.DesignationOrderByInput, List[types.DesignationOrderByInput]]] = None,
        distinct: Optional[List[types.DesignationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Designation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Designation records returned
        skip
            Ignore the first N results
        where
            Designation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Designation model
        order
            Order the returned Designation records by any field
        distinct
            Filter Designation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Designation]
            The list of all Designation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Designation records
        designations = await Designation.prisma().find_many(take=10)

        # find the first 5 Designation records ordered by the designationCode field
        designations = await Designation.prisma().find_many(
            take=5,
            order={
                'designationCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DesignationWhereInput] = None,
        cursor: Optional[types.DesignationWhereUniqueInput] = None,
        include: Optional[types.DesignationInclude] = None,
        order: Optional[Union[types.DesignationOrderByInput, List[types.DesignationOrderByInput]]] = None,
        distinct: Optional[List[types.DesignationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Designation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Designation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Designation model
        order
            Order the returned Designation records by any field
        distinct
            Filter Designation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Designation
            The first Designation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Designation record ordered by the level field
        designation = await Designation.prisma().find_first(
            skip=1,
            order={
                'level': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DesignationWhereInput] = None,
        cursor: Optional[types.DesignationWhereUniqueInput] = None,
        include: Optional[types.DesignationInclude] = None,
        order: Optional[Union[types.DesignationOrderByInput, List[types.DesignationOrderByInput]]] = None,
        distinct: Optional[List[types.DesignationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Designation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Designation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Designation model
        order
            Order the returned Designation records by any field
        distinct
            Filter Designation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Designation
            The first Designation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Designation record ordered by the createdAt field
        designation = await Designation.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DesignationUpdateInput,
        where: types.DesignationWhereUniqueInput,
        include: Optional[types.DesignationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Designation record.

        Parameters
        ----------
        data
            Designation record data specifying what to update
        where
            Designation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Designation model

        Returns
        -------
        prisma.models.Designation
            The updated Designation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        designation = await Designation.prisma().update(
            where={
                'id': 'caaaedabfc',
            },
            data={
                # data to update the Designation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DesignationWhereUniqueInput,
        data: types.DesignationUpsertInput,
        include: Optional[types.DesignationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Designation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Designation model

        Returns
        -------
        prisma.models.Designation
            The created or updated Designation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        designation = await Designation.prisma().upsert(
            where={
                'id': 'bigibebcib',
            },
            data={
                'create': {
                    'id': 'bigibebcib',
                    'designationName': 'heejgedji',
                    'designationCode': 'bjgjgibgbf',
                    'level': 1116175964,
                },
                'update': {
                    'designationName': 'heejgedji',
                    'designationCode': 'bjgjgibgbf',
                    'level': 1116175964,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DesignationUpdateManyMutationInput,
        where: types.DesignationWhereInput,
    ) -> int:
        """Update multiple Designation records

        Parameters
        ----------
        data
            Designation data to update the selected Designation records to
        where
            Filter to select the Designation records to update

        Returns
        -------
        int
            The total number of Designation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Designation records
        total = await Designation.prisma().update_many(
            data={
                'createdBy': 'bigaiehgcc'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DesignationWhereInput] = None,
        cursor: Optional[types.DesignationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Designation records present in the database

        Parameters
        ----------
        select
            Select the Designation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Designation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DesignationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Designation.prisma().count()

        # results: prisma.types.DesignationCountAggregateOutput
        results = await Designation.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DesignationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DesignationWhereInput] = None,
        cursor: Optional[types.DesignationWhereUniqueInput] = None,
    ) -> types.DesignationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DesignationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DesignationWhereInput] = None,
        cursor: Optional[types.DesignationWhereUniqueInput] = None,
    ) -> Union[int, types.DesignationCountAggregateOutput]:
        """Count the number of Designation records present in the database

        Parameters
        ----------
        select
            Select the Designation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Designation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DesignationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Designation.prisma().count()

        # results: prisma.types.DesignationCountAggregateOutput
        results = await Designation.prisma().count(
            select={
                '_all': True,
                'updatedBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DesignationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DesignationWhereInput] = None
    ) -> int:
        """Delete multiple Designation records.

        Parameters
        ----------
        where
            Optional Designation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Designation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Designation records
        total = await Designation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DesignationScalarFieldKeys'],
        *,
        where: Optional['types.DesignationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DesignationAvgAggregateInput'] = None,
        sum: Optional['types.DesignationSumAggregateInput'] = None,
        min: Optional['types.DesignationMinAggregateInput'] = None,
        max: Optional['types.DesignationMaxAggregateInput'] = None,
        having: Optional['types.DesignationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DesignationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DesignationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DesignationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DesignationGroupByOutput']:
        """Group Designation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Designation fields to group records by
        where
            Designation filter to select records
        take
            Limit the maximum number of Designation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DesignationGroupByOutput]
            A list of dictionaries representing the Designation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Designation records by id values
        # and count how many records are in each group
        results = await Designation.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DepartmentTypeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.DepartmentType]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await DepartmentType.prisma().query_raw(
            'SELECT * FROM DepartmentType WHERE id = $1',
            'beeifcbebf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.DepartmentType
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await DepartmentType.prisma().query_first(
            'SELECT * FROM DepartmentType WHERE typeName = $1',
            'bgcigfahea',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DepartmentTypeCreateInput,
        include: Optional[types.DepartmentTypeInclude] = None
    ) -> _PrismaModelT:
        """Create a new DepartmentType record.

        Parameters
        ----------
        data
            DepartmentType record data
        include
            Specifies which relations should be loaded on the returned DepartmentType model

        Returns
        -------
        prisma.models.DepartmentType
            The created DepartmentType record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a DepartmentType record from just the required fields
        departmenttype = await DepartmentType.prisma().create(
            data={
                # data to create a DepartmentType record
                'typeName': 'bcejgaggif',
                'typeCode': 'idfjadbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DepartmentTypeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple DepartmentType records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of DepartmentType record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await DepartmentType.prisma().create_many(
            data=[
                {
                    # data to create a DepartmentType record
                    'typeName': 'hgdhbjhhj',
                    'typeCode': 'ecjjjfbae',
                },
                {
                    # data to create a DepartmentType record
                    'typeName': 'bhhfibbigf',
                    'typeCode': 'ijdbeffgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DepartmentTypeWhereUniqueInput,
        include: Optional[types.DepartmentTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single DepartmentType record.

        Parameters
        ----------
        where
            DepartmentType filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned DepartmentType model

        Returns
        -------
        prisma.models.DepartmentType
            The deleted DepartmentType record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmenttype = await DepartmentType.prisma().delete(
            where={
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DepartmentTypeWhereUniqueInput,
        include: Optional[types.DepartmentTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique DepartmentType record.

        Parameters
        ----------
        where
            DepartmentType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DepartmentType model

        Returns
        -------
        prisma.models.DepartmentType
            The found DepartmentType record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmenttype = await DepartmentType.prisma().find_unique(
            where={
                'id': 'cbachdgfce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DepartmentTypeWhereUniqueInput,
        include: Optional[types.DepartmentTypeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique DepartmentType record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            DepartmentType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DepartmentType model

        Returns
        -------
        prisma.models.DepartmentType
            The found DepartmentType record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmenttype = await DepartmentType.prisma().find_unique_or_raise(
            where={
                'id': 'chbfcacbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentTypeWhereInput] = None,
        cursor: Optional[types.DepartmentTypeWhereUniqueInput] = None,
        include: Optional[types.DepartmentTypeInclude] = None,
        order: Optional[Union[types.DepartmentTypeOrderByInput, List[types.DepartmentTypeOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentTypeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple DepartmentType records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of DepartmentType records returned
        skip
            Ignore the first N results
        where
            DepartmentType filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DepartmentType model
        order
            Order the returned DepartmentType records by any field
        distinct
            Filter DepartmentType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.DepartmentType]
            The list of all DepartmentType records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 DepartmentType records
        departmenttypes = await DepartmentType.prisma().find_many(take=10)

        # find the first 5 DepartmentType records ordered by the typeCode field
        departmenttypes = await DepartmentType.prisma().find_many(
            take=5,
            order={
                'typeCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentTypeWhereInput] = None,
        cursor: Optional[types.DepartmentTypeWhereUniqueInput] = None,
        include: Optional[types.DepartmentTypeInclude] = None,
        order: Optional[Union[types.DepartmentTypeOrderByInput, List[types.DepartmentTypeOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentTypeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single DepartmentType record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DepartmentType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DepartmentType model
        order
            Order the returned DepartmentType records by any field
        distinct
            Filter DepartmentType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DepartmentType
            The first DepartmentType record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DepartmentType record ordered by the createdAt field
        departmenttype = await DepartmentType.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentTypeWhereInput] = None,
        cursor: Optional[types.DepartmentTypeWhereUniqueInput] = None,
        include: Optional[types.DepartmentTypeInclude] = None,
        order: Optional[Union[types.DepartmentTypeOrderByInput, List[types.DepartmentTypeOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentTypeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single DepartmentType record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DepartmentType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DepartmentType model
        order
            Order the returned DepartmentType records by any field
        distinct
            Filter DepartmentType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DepartmentType
            The first DepartmentType record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DepartmentType record ordered by the createdBy field
        departmenttype = await DepartmentType.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DepartmentTypeUpdateInput,
        where: types.DepartmentTypeWhereUniqueInput,
        include: Optional[types.DepartmentTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single DepartmentType record.

        Parameters
        ----------
        data
            DepartmentType record data specifying what to update
        where
            DepartmentType filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned DepartmentType model

        Returns
        -------
        prisma.models.DepartmentType
            The updated DepartmentType record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        departmenttype = await DepartmentType.prisma().update(
            where={
                'id': 'efggddide',
            },
            data={
                # data to update the DepartmentType record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DepartmentTypeWhereUniqueInput,
        data: types.DepartmentTypeUpsertInput,
        include: Optional[types.DepartmentTypeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            DepartmentType filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned DepartmentType model

        Returns
        -------
        prisma.models.DepartmentType
            The created or updated DepartmentType record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmenttype = await DepartmentType.prisma().upsert(
            where={
                'id': 'caficfigfb',
            },
            data={
                'create': {
                    'id': 'caficfigfb',
                    'typeName': 'bhhfibbigf',
                    'typeCode': 'ijdbeffgg',
                },
                'update': {
                    'typeName': 'bhhfibbigf',
                    'typeCode': 'ijdbeffgg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DepartmentTypeUpdateManyMutationInput,
        where: types.DepartmentTypeWhereInput,
    ) -> int:
        """Update multiple DepartmentType records

        Parameters
        ----------
        data
            DepartmentType data to update the selected DepartmentType records to
        where
            Filter to select the DepartmentType records to update

        Returns
        -------
        int
            The total number of DepartmentType records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all DepartmentType records
        total = await DepartmentType.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentTypeWhereInput] = None,
        cursor: Optional[types.DepartmentTypeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of DepartmentType records present in the database

        Parameters
        ----------
        select
            Select the DepartmentType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DepartmentType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DepartmentType.prisma().count()

        # results: prisma.types.DepartmentTypeCountAggregateOutput
        results = await DepartmentType.prisma().count(
            select={
                '_all': True,
                'updatedBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DepartmentTypeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentTypeWhereInput] = None,
        cursor: Optional[types.DepartmentTypeWhereUniqueInput] = None,
    ) -> types.DepartmentTypeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DepartmentTypeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentTypeWhereInput] = None,
        cursor: Optional[types.DepartmentTypeWhereUniqueInput] = None,
    ) -> Union[int, types.DepartmentTypeCountAggregateOutput]:
        """Count the number of DepartmentType records present in the database

        Parameters
        ----------
        select
            Select the DepartmentType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DepartmentType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DepartmentType.prisma().count()

        # results: prisma.types.DepartmentTypeCountAggregateOutput
        results = await DepartmentType.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DepartmentTypeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DepartmentTypeWhereInput] = None
    ) -> int:
        """Delete multiple DepartmentType records.

        Parameters
        ----------
        where
            Optional DepartmentType filter to find the records to be deleted

        Returns
        -------
        int
            The total number of DepartmentType records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all DepartmentType records
        total = await DepartmentType.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DepartmentTypeScalarFieldKeys'],
        *,
        where: Optional['types.DepartmentTypeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DepartmentTypeAvgAggregateInput'] = None,
        sum: Optional['types.DepartmentTypeSumAggregateInput'] = None,
        min: Optional['types.DepartmentTypeMinAggregateInput'] = None,
        max: Optional['types.DepartmentTypeMaxAggregateInput'] = None,
        having: Optional['types.DepartmentTypeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DepartmentTypeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DepartmentTypeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DepartmentTypeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DepartmentTypeGroupByOutput']:
        """Group DepartmentType records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar DepartmentType fields to group records by
        where
            DepartmentType filter to select records
        take
            Limit the maximum number of DepartmentType records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DepartmentTypeGroupByOutput]
            A list of dictionaries representing the DepartmentType record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group DepartmentType records by typeName values
        # and count how many records are in each group
        results = await DepartmentType.prisma().group_by(
            ['typeName'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DepartmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Department]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Department.prisma().query_raw(
            'SELECT * FROM Department WHERE id = $1',
            'bfidgijfjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Department
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Department.prisma().query_first(
            'SELECT * FROM Department WHERE departmentName = $1',
            'ihieecagf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DepartmentCreateInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Department record.

        Parameters
        ----------
        data
            Department record data
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The created Department record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Department record from just the required fields
        department = await Department.prisma().create(
            data={
                # data to create a Department record
                'departmentName': 'bghfciaafe',
                'departmentCode': 'bgchfhgceh',
                'departmentTypeId': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DepartmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Department records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Department record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Department.prisma().create_many(
            data=[
                {
                    # data to create a Department record
                    'departmentName': 'gaddfhfh',
                    'departmentCode': 'gieegcbeg',
                    'departmentTypeId': 'bgcffadich',
                },
                {
                    # data to create a Department record
                    'departmentName': 'fcbichhci',
                    'departmentCode': 'bcggadccgf',
                    'departmentTypeId': 'jdcfdcgc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Department record.

        Parameters
        ----------
        where
            Department filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The deleted Department record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().delete(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Department record.

        Parameters
        ----------
        where
            Department filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The found Department record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().find_unique(
            where={
                'id': 'gifdddbia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Department record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Department filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The found Department record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().find_unique_or_raise(
            where={
                'id': 'bchehecef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
        include: Optional[types.DepartmentInclude] = None,
        order: Optional[Union[types.DepartmentOrderByInput, List[types.DepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Department records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Department records returned
        skip
            Ignore the first N results
        where
            Department filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Department model
        order
            Order the returned Department records by any field
        distinct
            Filter Department records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Department]
            The list of all Department records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Department records
        departments = await Department.prisma().find_many(take=10)

        # find the first 5 Department records ordered by the departmentCode field
        departments = await Department.prisma().find_many(
            take=5,
            order={
                'departmentCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
        include: Optional[types.DepartmentInclude] = None,
        order: Optional[Union[types.DepartmentOrderByInput, List[types.DepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Department record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Department filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Department model
        order
            Order the returned Department records by any field
        distinct
            Filter Department records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Department
            The first Department record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Department record ordered by the departmentTypeId field
        department = await Department.prisma().find_first(
            skip=1,
            order={
                'departmentTypeId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
        include: Optional[types.DepartmentInclude] = None,
        order: Optional[Union[types.DepartmentOrderByInput, List[types.DepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Department record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Department filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Department model
        order
            Order the returned Department records by any field
        distinct
            Filter Department records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Department
            The first Department record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Department record ordered by the createdAt field
        department = await Department.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DepartmentUpdateInput,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Department record.

        Parameters
        ----------
        data
            Department record data specifying what to update
        where
            Department filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The updated Department record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        department = await Department.prisma().update(
            where={
                'id': 'jeijcbhfe',
            },
            data={
                # data to update the Department record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DepartmentWhereUniqueInput,
        data: types.DepartmentUpsertInput,
        include: Optional[types.DepartmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Department filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The created or updated Department record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().upsert(
            where={
                'id': 'bjgejjabff',
            },
            data={
                'create': {
                    'id': 'bjgejjabff',
                    'departmentName': 'fcbichhci',
                    'departmentCode': 'bcggadccgf',
                    'departmentTypeId': 'jdcfdcgc',
                },
                'update': {
                    'departmentName': 'fcbichhci',
                    'departmentCode': 'bcggadccgf',
                    'departmentTypeId': 'jdcfdcgc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DepartmentUpdateManyMutationInput,
        where: types.DepartmentWhereInput,
    ) -> int:
        """Update multiple Department records

        Parameters
        ----------
        data
            Department data to update the selected Department records to
        where
            Filter to select the Department records to update

        Returns
        -------
        int
            The total number of Department records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Department records
        total = await Department.prisma().update_many(
            data={
                'createdBy': 'bcciijbibg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Department records present in the database

        Parameters
        ----------
        select
            Select the Department fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Department filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Department.prisma().count()

        # results: prisma.types.DepartmentCountAggregateOutput
        results = await Department.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DepartmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
    ) -> types.DepartmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DepartmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
    ) -> Union[int, types.DepartmentCountAggregateOutput]:
        """Count the number of Department records present in the database

        Parameters
        ----------
        select
            Select the Department fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Department filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Department.prisma().count()

        # results: prisma.types.DepartmentCountAggregateOutput
        results = await Department.prisma().count(
            select={
                '_all': True,
                'updatedBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DepartmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DepartmentWhereInput] = None
    ) -> int:
        """Delete multiple Department records.

        Parameters
        ----------
        where
            Optional Department filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Department records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Department records
        total = await Department.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DepartmentScalarFieldKeys'],
        *,
        where: Optional['types.DepartmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DepartmentAvgAggregateInput'] = None,
        sum: Optional['types.DepartmentSumAggregateInput'] = None,
        min: Optional['types.DepartmentMinAggregateInput'] = None,
        max: Optional['types.DepartmentMaxAggregateInput'] = None,
        having: Optional['types.DepartmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DepartmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DepartmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DepartmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DepartmentGroupByOutput']:
        """Group Department records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Department fields to group records by
        where
            Department filter to select records
        take
            Limit the maximum number of Department records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DepartmentGroupByOutput]
            A list of dictionaries representing the Department record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Department records by id values
        # and count how many records are in each group
        results = await Department.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RoleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Role]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Role.prisma().query_raw(
            'SELECT * FROM Role WHERE id = $1',
            'cffcachfd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Role
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Role.prisma().query_first(
            'SELECT * FROM Role WHERE roleName = $1',
            'bccdfhdigc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RoleCreateInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Create a new Role record.

        Parameters
        ----------
        data
            Role record data
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created Role record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Role record from just the required fields
        role = await Role.prisma().create(
            data={
                # data to create a Role record
                'roleName': 'febcgjbfj',
                'roleCode': 'bageiegghg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RoleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Role records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Role record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Role.prisma().create_many(
            data=[
                {
                    # data to create a Role record
                    'roleName': 'faidicegb',
                    'roleCode': 'bacecgfhbe',
                },
                {
                    # data to create a Role record
                    'roleName': 'ihcahiead',
                    'roleCode': 'biheheiajg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Role record.

        Parameters
        ----------
        where
            Role filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The deleted Role record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().delete(
            where={
                'id': 'jbgijghgb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Role record.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().find_unique(
            where={
                'id': 'hgjcghfbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Role record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().find_unique_or_raise(
            where={
                'id': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Role records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N results
        where
            Role filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Role]
            The list of all Role records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Role records
        roles = await Role.prisma().find_many(take=10)

        # find the first 5 Role records ordered by the roleCode field
        roles = await Role.prisma().find_many(
            take=5,
            order={
                'roleCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Role record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the description field
        role = await Role.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Role record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the createdAt field
        role = await Role.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RoleUpdateInput,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Role record.

        Parameters
        ----------
        data
            Role record data specifying what to update
        where
            Role filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The updated Role record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        role = await Role.prisma().update(
            where={
                'id': 'jchciaee',
            },
            data={
                # data to update the Role record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RoleWhereUniqueInput,
        data: types.RoleUpsertInput,
        include: Optional[types.RoleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Role filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created or updated Role record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().upsert(
            where={
                'id': 'deeificjd',
            },
            data={
                'create': {
                    'id': 'deeificjd',
                    'roleName': 'ihcahiead',
                    'roleCode': 'biheheiajg',
                },
                'update': {
                    'roleName': 'ihcahiead',
                    'roleCode': 'biheheiajg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RoleUpdateManyMutationInput,
        where: types.RoleWhereInput,
    ) -> int:
        """Update multiple Role records

        Parameters
        ----------
        data
            Role data to update the selected Role records to
        where
            Filter to select the Role records to update

        Returns
        -------
        int
            The total number of Role records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Role records
        total = await Role.prisma().update_many(
            data={
                'createdBy': 'bbcbhebbda'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = await Role.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RoleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> types.RoleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RoleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> Union[int, types.RoleCountAggregateOutput]:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = await Role.prisma().count(
            select={
                '_all': True,
                'updatedBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RoleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RoleWhereInput] = None
    ) -> int:
        """Delete multiple Role records.

        Parameters
        ----------
        where
            Optional Role filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Role records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Role records
        total = await Role.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RoleScalarFieldKeys'],
        *,
        where: Optional['types.RoleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RoleAvgAggregateInput'] = None,
        sum: Optional['types.RoleSumAggregateInput'] = None,
        min: Optional['types.RoleMinAggregateInput'] = None,
        max: Optional['types.RoleMaxAggregateInput'] = None,
        having: Optional['types.RoleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RoleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RoleGroupByOutput']:
        """Group Role records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Role fields to group records by
        where
            Role filter to select records
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RoleGroupByOutput]
            A list of dictionaries representing the Role record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Role records by id values
        # and count how many records are in each group
        results = await Role.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransactionTypeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TransactionType]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TransactionType.prisma().query_raw(
            'SELECT * FROM TransactionType WHERE id = $1',
            'bejfijgcfb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TransactionType
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TransactionType.prisma().query_first(
            'SELECT * FROM TransactionType WHERE typeName = $1',
            'caifcbgii',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TransactionTypeCreateInput,
        include: Optional[types.TransactionTypeInclude] = None
    ) -> _PrismaModelT:
        """Create a new TransactionType record.

        Parameters
        ----------
        data
            TransactionType record data
        include
            Specifies which relations should be loaded on the returned TransactionType model

        Returns
        -------
        prisma.models.TransactionType
            The created TransactionType record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TransactionType record from just the required fields
        transactiontype = await TransactionType.prisma().create(
            data={
                # data to create a TransactionType record
                'typeName': 'igaibbfgj',
                'typeCode': 'bggajdcbbi',
                'isCredit': False,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TransactionTypeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TransactionType records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TransactionType record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TransactionType.prisma().create_many(
            data=[
                {
                    # data to create a TransactionType record
                    'typeName': 'hdgcajhjg',
                    'typeCode': 'ejdjahicb',
                    'isCredit': True,
                },
                {
                    # data to create a TransactionType record
                    'typeName': 'gfeaahdeh',
                    'typeCode': 'bjafcgbffc',
                    'isCredit': False,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TransactionTypeWhereUniqueInput,
        include: Optional[types.TransactionTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TransactionType record.

        Parameters
        ----------
        where
            TransactionType filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TransactionType model

        Returns
        -------
        prisma.models.TransactionType
            The deleted TransactionType record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transactiontype = await TransactionType.prisma().delete(
            where={
                'id': 'bdjidcidac',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TransactionTypeWhereUniqueInput,
        include: Optional[types.TransactionTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TransactionType record.

        Parameters
        ----------
        where
            TransactionType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TransactionType model

        Returns
        -------
        prisma.models.TransactionType
            The found TransactionType record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transactiontype = await TransactionType.prisma().find_unique(
            where={
                'id': 'ifgaaagff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TransactionTypeWhereUniqueInput,
        include: Optional[types.TransactionTypeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TransactionType record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TransactionType filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TransactionType model

        Returns
        -------
        prisma.models.TransactionType
            The found TransactionType record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transactiontype = await TransactionType.prisma().find_unique_or_raise(
            where={
                'id': 'befcddgjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionTypeWhereInput] = None,
        cursor: Optional[types.TransactionTypeWhereUniqueInput] = None,
        include: Optional[types.TransactionTypeInclude] = None,
        order: Optional[Union[types.TransactionTypeOrderByInput, List[types.TransactionTypeOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionTypeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TransactionType records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TransactionType records returned
        skip
            Ignore the first N results
        where
            TransactionType filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TransactionType model
        order
            Order the returned TransactionType records by any field
        distinct
            Filter TransactionType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TransactionType]
            The list of all TransactionType records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TransactionType records
        transactiontypes = await TransactionType.prisma().find_many(take=10)

        # find the first 5 TransactionType records ordered by the typeCode field
        transactiontypes = await TransactionType.prisma().find_many(
            take=5,
            order={
                'typeCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionTypeWhereInput] = None,
        cursor: Optional[types.TransactionTypeWhereUniqueInput] = None,
        include: Optional[types.TransactionTypeInclude] = None,
        order: Optional[Union[types.TransactionTypeOrderByInput, List[types.TransactionTypeOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionTypeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TransactionType record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TransactionType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TransactionType model
        order
            Order the returned TransactionType records by any field
        distinct
            Filter TransactionType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TransactionType
            The first TransactionType record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TransactionType record ordered by the description field
        transactiontype = await TransactionType.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionTypeWhereInput] = None,
        cursor: Optional[types.TransactionTypeWhereUniqueInput] = None,
        include: Optional[types.TransactionTypeInclude] = None,
        order: Optional[Union[types.TransactionTypeOrderByInput, List[types.TransactionTypeOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionTypeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TransactionType record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TransactionType filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TransactionType model
        order
            Order the returned TransactionType records by any field
        distinct
            Filter TransactionType records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TransactionType
            The first TransactionType record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TransactionType record ordered by the isCredit field
        transactiontype = await TransactionType.prisma().find_first_or_raise(
            skip=1,
            order={
                'isCredit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TransactionTypeUpdateInput,
        where: types.TransactionTypeWhereUniqueInput,
        include: Optional[types.TransactionTypeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TransactionType record.

        Parameters
        ----------
        data
            TransactionType record data specifying what to update
        where
            TransactionType filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TransactionType model

        Returns
        -------
        prisma.models.TransactionType
            The updated TransactionType record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transactiontype = await TransactionType.prisma().update(
            where={
                'id': 'bfhdbjjgfd',
            },
            data={
                # data to update the TransactionType record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TransactionTypeWhereUniqueInput,
        data: types.TransactionTypeUpsertInput,
        include: Optional[types.TransactionTypeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TransactionType filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TransactionType model

        Returns
        -------
        prisma.models.TransactionType
            The created or updated TransactionType record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transactiontype = await TransactionType.prisma().upsert(
            where={
                'id': 'cabdjadaji',
            },
            data={
                'create': {
                    'id': 'cabdjadaji',
                    'typeName': 'gfeaahdeh',
                    'typeCode': 'bjafcgbffc',
                    'isCredit': False,
                },
                'update': {
                    'typeName': 'gfeaahdeh',
                    'typeCode': 'bjafcgbffc',
                    'isCredit': False,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TransactionTypeUpdateManyMutationInput,
        where: types.TransactionTypeWhereInput,
    ) -> int:
        """Update multiple TransactionType records

        Parameters
        ----------
        data
            TransactionType data to update the selected TransactionType records to
        where
            Filter to select the TransactionType records to update

        Returns
        -------
        int
            The total number of TransactionType records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TransactionType records
        total = await TransactionType.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionTypeWhereInput] = None,
        cursor: Optional[types.TransactionTypeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TransactionType records present in the database

        Parameters
        ----------
        select
            Select the TransactionType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TransactionType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TransactionType.prisma().count()

        # results: prisma.types.TransactionTypeCountAggregateOutput
        results = await TransactionType.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TransactionTypeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionTypeWhereInput] = None,
        cursor: Optional[types.TransactionTypeWhereUniqueInput] = None,
    ) -> types.TransactionTypeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TransactionTypeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionTypeWhereInput] = None,
        cursor: Optional[types.TransactionTypeWhereUniqueInput] = None,
    ) -> Union[int, types.TransactionTypeCountAggregateOutput]:
        """Count the number of TransactionType records present in the database

        Parameters
        ----------
        select
            Select the TransactionType fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TransactionType filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionTypeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TransactionType.prisma().count()

        # results: prisma.types.TransactionTypeCountAggregateOutput
        results = await TransactionType.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransactionTypeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TransactionTypeWhereInput] = None
    ) -> int:
        """Delete multiple TransactionType records.

        Parameters
        ----------
        where
            Optional TransactionType filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TransactionType records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TransactionType records
        total = await TransactionType.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TransactionTypeScalarFieldKeys'],
        *,
        where: Optional['types.TransactionTypeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransactionTypeAvgAggregateInput'] = None,
        sum: Optional['types.TransactionTypeSumAggregateInput'] = None,
        min: Optional['types.TransactionTypeMinAggregateInput'] = None,
        max: Optional['types.TransactionTypeMaxAggregateInput'] = None,
        having: Optional['types.TransactionTypeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransactionTypeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransactionTypeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransactionTypeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransactionTypeGroupByOutput']:
        """Group TransactionType records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TransactionType fields to group records by
        where
            TransactionType filter to select records
        take
            Limit the maximum number of TransactionType records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransactionTypeGroupByOutput]
            A list of dictionaries representing the TransactionType record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TransactionType records by updatedBy values
        # and count how many records are in each group
        results = await TransactionType.prisma().group_by(
            ['updatedBy'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RewardCategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RewardCategory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RewardCategory.prisma().query_raw(
            'SELECT * FROM RewardCategory WHERE id = $1',
            'faajgfadf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RewardCategory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RewardCategory.prisma().query_first(
            'SELECT * FROM RewardCategory WHERE categoryName = $1',
            'biaagcedjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RewardCategoryCreateInput,
        include: Optional[types.RewardCategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new RewardCategory record.

        Parameters
        ----------
        data
            RewardCategory record data
        include
            Specifies which relations should be loaded on the returned RewardCategory model

        Returns
        -------
        prisma.models.RewardCategory
            The created RewardCategory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RewardCategory record from just the required fields
        rewardcategory = await RewardCategory.prisma().create(
            data={
                # data to create a RewardCategory record
                'categoryName': 'cahhaghecf',
                'categoryCode': 'bghcbbcidi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RewardCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RewardCategory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RewardCategory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RewardCategory.prisma().create_many(
            data=[
                {
                    # data to create a RewardCategory record
                    'categoryName': 'jcgghhgdj',
                    'categoryCode': 'beehgcebbg',
                },
                {
                    # data to create a RewardCategory record
                    'categoryName': 'bhdiaidiaf',
                    'categoryCode': 'deajegcfi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RewardCategoryWhereUniqueInput,
        include: Optional[types.RewardCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RewardCategory record.

        Parameters
        ----------
        where
            RewardCategory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RewardCategory model

        Returns
        -------
        prisma.models.RewardCategory
            The deleted RewardCategory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcategory = await RewardCategory.prisma().delete(
            where={
                'id': 'gabahhhjf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RewardCategoryWhereUniqueInput,
        include: Optional[types.RewardCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RewardCategory record.

        Parameters
        ----------
        where
            RewardCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RewardCategory model

        Returns
        -------
        prisma.models.RewardCategory
            The found RewardCategory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcategory = await RewardCategory.prisma().find_unique(
            where={
                'id': 'cjagadcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RewardCategoryWhereUniqueInput,
        include: Optional[types.RewardCategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RewardCategory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RewardCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RewardCategory model

        Returns
        -------
        prisma.models.RewardCategory
            The found RewardCategory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcategory = await RewardCategory.prisma().find_unique_or_raise(
            where={
                'id': 'bifficggej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCategoryWhereInput] = None,
        cursor: Optional[types.RewardCategoryWhereUniqueInput] = None,
        include: Optional[types.RewardCategoryInclude] = None,
        order: Optional[Union[types.RewardCategoryOrderByInput, List[types.RewardCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.RewardCategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RewardCategory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RewardCategory records returned
        skip
            Ignore the first N results
        where
            RewardCategory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardCategory model
        order
            Order the returned RewardCategory records by any field
        distinct
            Filter RewardCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RewardCategory]
            The list of all RewardCategory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RewardCategory records
        rewardcategorys = await RewardCategory.prisma().find_many(take=10)

        # find the first 5 RewardCategory records ordered by the categoryCode field
        rewardcategorys = await RewardCategory.prisma().find_many(
            take=5,
            order={
                'categoryCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RewardCategoryWhereInput] = None,
        cursor: Optional[types.RewardCategoryWhereUniqueInput] = None,
        include: Optional[types.RewardCategoryInclude] = None,
        order: Optional[Union[types.RewardCategoryOrderByInput, List[types.RewardCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.RewardCategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RewardCategory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RewardCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardCategory model
        order
            Order the returned RewardCategory records by any field
        distinct
            Filter RewardCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RewardCategory
            The first RewardCategory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RewardCategory record ordered by the description field
        rewardcategory = await RewardCategory.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RewardCategoryWhereInput] = None,
        cursor: Optional[types.RewardCategoryWhereUniqueInput] = None,
        include: Optional[types.RewardCategoryInclude] = None,
        order: Optional[Union[types.RewardCategoryOrderByInput, List[types.RewardCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.RewardCategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RewardCategory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RewardCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardCategory model
        order
            Order the returned RewardCategory records by any field
        distinct
            Filter RewardCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RewardCategory
            The first RewardCategory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RewardCategory record ordered by the isActive field
        rewardcategory = await RewardCategory.prisma().find_first_or_raise(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RewardCategoryUpdateInput,
        where: types.RewardCategoryWhereUniqueInput,
        include: Optional[types.RewardCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RewardCategory record.

        Parameters
        ----------
        data
            RewardCategory record data specifying what to update
        where
            RewardCategory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RewardCategory model

        Returns
        -------
        prisma.models.RewardCategory
            The updated RewardCategory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rewardcategory = await RewardCategory.prisma().update(
            where={
                'id': 'bgbbaajbic',
            },
            data={
                # data to update the RewardCategory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RewardCategoryWhereUniqueInput,
        data: types.RewardCategoryUpsertInput,
        include: Optional[types.RewardCategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RewardCategory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RewardCategory model

        Returns
        -------
        prisma.models.RewardCategory
            The created or updated RewardCategory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcategory = await RewardCategory.prisma().upsert(
            where={
                'id': 'eegghdhjb',
            },
            data={
                'create': {
                    'id': 'eegghdhjb',
                    'categoryName': 'bhdiaidiaf',
                    'categoryCode': 'deajegcfi',
                },
                'update': {
                    'categoryName': 'bhdiaidiaf',
                    'categoryCode': 'deajegcfi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RewardCategoryUpdateManyMutationInput,
        where: types.RewardCategoryWhereInput,
    ) -> int:
        """Update multiple RewardCategory records

        Parameters
        ----------
        data
            RewardCategory data to update the selected RewardCategory records to
        where
            Filter to select the RewardCategory records to update

        Returns
        -------
        int
            The total number of RewardCategory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RewardCategory records
        total = await RewardCategory.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCategoryWhereInput] = None,
        cursor: Optional[types.RewardCategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RewardCategory records present in the database

        Parameters
        ----------
        select
            Select the RewardCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RewardCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RewardCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RewardCategory.prisma().count()

        # results: prisma.types.RewardCategoryCountAggregateOutput
        results = await RewardCategory.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RewardCategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCategoryWhereInput] = None,
        cursor: Optional[types.RewardCategoryWhereUniqueInput] = None,
    ) -> types.RewardCategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RewardCategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCategoryWhereInput] = None,
        cursor: Optional[types.RewardCategoryWhereUniqueInput] = None,
    ) -> Union[int, types.RewardCategoryCountAggregateOutput]:
        """Count the number of RewardCategory records present in the database

        Parameters
        ----------
        select
            Select the RewardCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RewardCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RewardCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RewardCategory.prisma().count()

        # results: prisma.types.RewardCategoryCountAggregateOutput
        results = await RewardCategory.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RewardCategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RewardCategoryWhereInput] = None
    ) -> int:
        """Delete multiple RewardCategory records.

        Parameters
        ----------
        where
            Optional RewardCategory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RewardCategory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RewardCategory records
        total = await RewardCategory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RewardCategoryScalarFieldKeys'],
        *,
        where: Optional['types.RewardCategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RewardCategoryAvgAggregateInput'] = None,
        sum: Optional['types.RewardCategorySumAggregateInput'] = None,
        min: Optional['types.RewardCategoryMinAggregateInput'] = None,
        max: Optional['types.RewardCategoryMaxAggregateInput'] = None,
        having: Optional['types.RewardCategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RewardCategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RewardCategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RewardCategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RewardCategoryGroupByOutput']:
        """Group RewardCategory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RewardCategory fields to group records by
        where
            RewardCategory filter to select records
        take
            Limit the maximum number of RewardCategory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RewardCategoryGroupByOutput]
            A list of dictionaries representing the RewardCategory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RewardCategory records by updatedBy values
        # and count how many records are in each group
        results = await RewardCategory.prisma().group_by(
            ['updatedBy'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RewardCatalogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RewardCatalog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RewardCatalog.prisma().query_raw(
            'SELECT * FROM RewardCatalog WHERE id = $1',
            'daafgidjg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RewardCatalog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RewardCatalog.prisma().query_first(
            'SELECT * FROM RewardCatalog WHERE rewardName = $1',
            'gdcgcgagj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RewardCatalogCreateInput,
        include: Optional[types.RewardCatalogInclude] = None
    ) -> _PrismaModelT:
        """Create a new RewardCatalog record.

        Parameters
        ----------
        data
            RewardCatalog record data
        include
            Specifies which relations should be loaded on the returned RewardCatalog model

        Returns
        -------
        prisma.models.RewardCatalog
            The created RewardCatalog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RewardCatalog record from just the required fields
        rewardcatalog = await RewardCatalog.prisma().create(
            data={
                # data to create a RewardCatalog record
                'rewardName': 'bhceabbgja',
                'rewardCode': 'ehabfhegh',
                'defaultPoints': 1209209912,
                'categoryId': 'bfdgheeegf',
                'minPoints': 424218998,
                'maxPoints': 2125632375,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RewardCatalogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RewardCatalog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RewardCatalog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RewardCatalog.prisma().create_many(
            data=[
                {
                    # data to create a RewardCatalog record
                    'rewardName': 'fdgjfbhia',
                    'rewardCode': 'jcehcdchh',
                    'defaultPoints': 1621937922,
                    'categoryId': 'bieiidcabj',
                    'minPoints': 1921528400,
                    'maxPoints': 2100427849,
                },
                {
                    # data to create a RewardCatalog record
                    'rewardName': 'iejbeaaeg',
                    'rewardCode': 'jcibfcbhf',
                    'defaultPoints': 273032060,
                    'categoryId': 'jicieifbh',
                    'minPoints': 510737498,
                    'maxPoints': 2117488267,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RewardCatalogWhereUniqueInput,
        include: Optional[types.RewardCatalogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RewardCatalog record.

        Parameters
        ----------
        where
            RewardCatalog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RewardCatalog model

        Returns
        -------
        prisma.models.RewardCatalog
            The deleted RewardCatalog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcatalog = await RewardCatalog.prisma().delete(
            where={
                'id': 'beabjeejdg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RewardCatalogWhereUniqueInput,
        include: Optional[types.RewardCatalogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RewardCatalog record.

        Parameters
        ----------
        where
            RewardCatalog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RewardCatalog model

        Returns
        -------
        prisma.models.RewardCatalog
            The found RewardCatalog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcatalog = await RewardCatalog.prisma().find_unique(
            where={
                'id': 'bcjhgahffd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RewardCatalogWhereUniqueInput,
        include: Optional[types.RewardCatalogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RewardCatalog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RewardCatalog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RewardCatalog model

        Returns
        -------
        prisma.models.RewardCatalog
            The found RewardCatalog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcatalog = await RewardCatalog.prisma().find_unique_or_raise(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCatalogWhereInput] = None,
        cursor: Optional[types.RewardCatalogWhereUniqueInput] = None,
        include: Optional[types.RewardCatalogInclude] = None,
        order: Optional[Union[types.RewardCatalogOrderByInput, List[types.RewardCatalogOrderByInput]]] = None,
        distinct: Optional[List[types.RewardCatalogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RewardCatalog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RewardCatalog records returned
        skip
            Ignore the first N results
        where
            RewardCatalog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardCatalog model
        order
            Order the returned RewardCatalog records by any field
        distinct
            Filter RewardCatalog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RewardCatalog]
            The list of all RewardCatalog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RewardCatalog records
        rewardcatalogs = await RewardCatalog.prisma().find_many(take=10)

        # find the first 5 RewardCatalog records ordered by the rewardCode field
        rewardcatalogs = await RewardCatalog.prisma().find_many(
            take=5,
            order={
                'rewardCode': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RewardCatalogWhereInput] = None,
        cursor: Optional[types.RewardCatalogWhereUniqueInput] = None,
        include: Optional[types.RewardCatalogInclude] = None,
        order: Optional[Union[types.RewardCatalogOrderByInput, List[types.RewardCatalogOrderByInput]]] = None,
        distinct: Optional[List[types.RewardCatalogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RewardCatalog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RewardCatalog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardCatalog model
        order
            Order the returned RewardCatalog records by any field
        distinct
            Filter RewardCatalog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RewardCatalog
            The first RewardCatalog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RewardCatalog record ordered by the description field
        rewardcatalog = await RewardCatalog.prisma().find_first(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RewardCatalogWhereInput] = None,
        cursor: Optional[types.RewardCatalogWhereUniqueInput] = None,
        include: Optional[types.RewardCatalogInclude] = None,
        order: Optional[Union[types.RewardCatalogOrderByInput, List[types.RewardCatalogOrderByInput]]] = None,
        distinct: Optional[List[types.RewardCatalogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RewardCatalog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RewardCatalog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardCatalog model
        order
            Order the returned RewardCatalog records by any field
        distinct
            Filter RewardCatalog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RewardCatalog
            The first RewardCatalog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RewardCatalog record ordered by the defaultPoints field
        rewardcatalog = await RewardCatalog.prisma().find_first_or_raise(
            skip=1,
            order={
                'defaultPoints': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RewardCatalogUpdateInput,
        where: types.RewardCatalogWhereUniqueInput,
        include: Optional[types.RewardCatalogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RewardCatalog record.

        Parameters
        ----------
        data
            RewardCatalog record data specifying what to update
        where
            RewardCatalog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RewardCatalog model

        Returns
        -------
        prisma.models.RewardCatalog
            The updated RewardCatalog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rewardcatalog = await RewardCatalog.prisma().update(
            where={
                'id': 'jhgidcgbf',
            },
            data={
                # data to update the RewardCatalog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RewardCatalogWhereUniqueInput,
        data: types.RewardCatalogUpsertInput,
        include: Optional[types.RewardCatalogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RewardCatalog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RewardCatalog model

        Returns
        -------
        prisma.models.RewardCatalog
            The created or updated RewardCatalog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardcatalog = await RewardCatalog.prisma().upsert(
            where={
                'id': 'bgjgecfejc',
            },
            data={
                'create': {
                    'id': 'bgjgecfejc',
                    'rewardName': 'iejbeaaeg',
                    'rewardCode': 'jcibfcbhf',
                    'defaultPoints': 273032060,
                    'categoryId': 'jicieifbh',
                    'minPoints': 510737498,
                    'maxPoints': 2117488267,
                },
                'update': {
                    'rewardName': 'iejbeaaeg',
                    'rewardCode': 'jcibfcbhf',
                    'defaultPoints': 273032060,
                    'categoryId': 'jicieifbh',
                    'minPoints': 510737498,
                    'maxPoints': 2117488267,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RewardCatalogUpdateManyMutationInput,
        where: types.RewardCatalogWhereInput,
    ) -> int:
        """Update multiple RewardCatalog records

        Parameters
        ----------
        data
            RewardCatalog data to update the selected RewardCatalog records to
        where
            Filter to select the RewardCatalog records to update

        Returns
        -------
        int
            The total number of RewardCatalog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RewardCatalog records
        total = await RewardCatalog.prisma().update_many(
            data={
                'categoryId': 'bgjcgchib'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCatalogWhereInput] = None,
        cursor: Optional[types.RewardCatalogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RewardCatalog records present in the database

        Parameters
        ----------
        select
            Select the RewardCatalog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RewardCatalog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RewardCatalogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RewardCatalog.prisma().count()

        # results: prisma.types.RewardCatalogCountAggregateOutput
        results = await RewardCatalog.prisma().count(
            select={
                '_all': True,
                'minPoints': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RewardCatalogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCatalogWhereInput] = None,
        cursor: Optional[types.RewardCatalogWhereUniqueInput] = None,
    ) -> types.RewardCatalogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RewardCatalogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardCatalogWhereInput] = None,
        cursor: Optional[types.RewardCatalogWhereUniqueInput] = None,
    ) -> Union[int, types.RewardCatalogCountAggregateOutput]:
        """Count the number of RewardCatalog records present in the database

        Parameters
        ----------
        select
            Select the RewardCatalog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RewardCatalog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RewardCatalogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RewardCatalog.prisma().count()

        # results: prisma.types.RewardCatalogCountAggregateOutput
        results = await RewardCatalog.prisma().count(
            select={
                '_all': True,
                'maxPoints': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RewardCatalogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RewardCatalogWhereInput] = None
    ) -> int:
        """Delete multiple RewardCatalog records.

        Parameters
        ----------
        where
            Optional RewardCatalog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RewardCatalog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RewardCatalog records
        total = await RewardCatalog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RewardCatalogScalarFieldKeys'],
        *,
        where: Optional['types.RewardCatalogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RewardCatalogAvgAggregateInput'] = None,
        sum: Optional['types.RewardCatalogSumAggregateInput'] = None,
        min: Optional['types.RewardCatalogMinAggregateInput'] = None,
        max: Optional['types.RewardCatalogMaxAggregateInput'] = None,
        having: Optional['types.RewardCatalogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RewardCatalogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RewardCatalogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RewardCatalogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RewardCatalogGroupByOutput']:
        """Group RewardCatalog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RewardCatalog fields to group records by
        where
            RewardCatalog filter to select records
        take
            Limit the maximum number of RewardCatalog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RewardCatalogGroupByOutput]
            A list of dictionaries representing the RewardCatalog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RewardCatalog records by isActive values
        # and count how many records are in each group
        results = await RewardCatalog.prisma().group_by(
            ['isActive'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmployeeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Employee]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Employee.prisma().query_raw(
            'SELECT * FROM Employee WHERE id = $1',
            'bacdaibgfa',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Employee
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Employee.prisma().query_first(
            'SELECT * FROM Employee WHERE username = $1',
            'dchgibach',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmployeeCreateInput,
        include: Optional[types.EmployeeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Employee record.

        Parameters
        ----------
        data
            Employee record data
        include
            Specifies which relations should be loaded on the returned Employee model

        Returns
        -------
        prisma.models.Employee
            The created Employee record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Employee record from just the required fields
        employee = await Employee.prisma().create(
            data={
                # data to create a Employee record
                'username': 'fchheijjc',
                'email': 'cacjdfhejh',
                'designationId': 'bdbifjhbbi',
                'passwordHash': 'cbccbbcdfb',
                'departmentId': 'bacejedaca',
                'dateOfJoining': datetime.datetime.utcnow(),
                'statusId': 'bhbhdahfaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmployeeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Employee records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Employee record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Employee.prisma().create_many(
            data=[
                {
                    # data to create a Employee record
                    'username': 'bfjibceaec',
                    'email': 'ibhgcdbgd',
                    'designationId': 'badaffhddg',
                    'passwordHash': 'bbdbfcfihd',
                    'departmentId': 'cbagggbji',
                    'dateOfJoining': datetime.datetime.utcnow(),
                    'statusId': 'bchgafhjed',
                },
                {
                    # data to create a Employee record
                    'username': 'heffgjdei',
                    'email': 'dahihgbeb',
                    'designationId': 'bgheaejbcc',
                    'passwordHash': 'bfcgifeged',
                    'departmentId': 'jfiahhbae',
                    'dateOfJoining': datetime.datetime.utcnow(),
                    'statusId': 'bfbdafajcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmployeeWhereUniqueInput,
        include: Optional[types.EmployeeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Employee record.

        Parameters
        ----------
        where
            Employee filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Employee model

        Returns
        -------
        prisma.models.Employee
            The deleted Employee record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employee = await Employee.prisma().delete(
            where={
                'id': 'caeghehde',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmployeeWhereUniqueInput,
        include: Optional[types.EmployeeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Employee record.

        Parameters
        ----------
        where
            Employee filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Employee model

        Returns
        -------
        prisma.models.Employee
            The found Employee record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employee = await Employee.prisma().find_unique(
            where={
                'id': 'caghgfbggd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmployeeWhereUniqueInput,
        include: Optional[types.EmployeeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Employee record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Employee filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Employee model

        Returns
        -------
        prisma.models.Employee
            The found Employee record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employee = await Employee.prisma().find_unique_or_raise(
            where={
                'id': 'bbidjbbjaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeWhereInput] = None,
        cursor: Optional[types.EmployeeWhereUniqueInput] = None,
        include: Optional[types.EmployeeInclude] = None,
        order: Optional[Union[types.EmployeeOrderByInput, List[types.EmployeeOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Employee records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Employee records returned
        skip
            Ignore the first N results
        where
            Employee filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Employee model
        order
            Order the returned Employee records by any field
        distinct
            Filter Employee records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Employee]
            The list of all Employee records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Employee records
        employees = await Employee.prisma().find_many(take=10)

        # find the first 5 Employee records ordered by the email field
        employees = await Employee.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeWhereInput] = None,
        cursor: Optional[types.EmployeeWhereUniqueInput] = None,
        include: Optional[types.EmployeeInclude] = None,
        order: Optional[Union[types.EmployeeOrderByInput, List[types.EmployeeOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Employee record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Employee filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Employee model
        order
            Order the returned Employee records by any field
        distinct
            Filter Employee records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Employee
            The first Employee record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Employee record ordered by the designationId field
        employee = await Employee.prisma().find_first(
            skip=1,
            order={
                'designationId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeWhereInput] = None,
        cursor: Optional[types.EmployeeWhereUniqueInput] = None,
        include: Optional[types.EmployeeInclude] = None,
        order: Optional[Union[types.EmployeeOrderByInput, List[types.EmployeeOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Employee record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Employee filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Employee model
        order
            Order the returned Employee records by any field
        distinct
            Filter Employee records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Employee
            The first Employee record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Employee record ordered by the passwordHash field
        employee = await Employee.prisma().find_first_or_raise(
            skip=1,
            order={
                'passwordHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmployeeUpdateInput,
        where: types.EmployeeWhereUniqueInput,
        include: Optional[types.EmployeeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Employee record.

        Parameters
        ----------
        data
            Employee record data specifying what to update
        where
            Employee filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Employee model

        Returns
        -------
        prisma.models.Employee
            The updated Employee record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        employee = await Employee.prisma().update(
            where={
                'id': 'bfijhaejdd',
            },
            data={
                # data to update the Employee record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmployeeWhereUniqueInput,
        data: types.EmployeeUpsertInput,
        include: Optional[types.EmployeeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Employee filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Employee model

        Returns
        -------
        prisma.models.Employee
            The created or updated Employee record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employee = await Employee.prisma().upsert(
            where={
                'id': 'bcedehfiji',
            },
            data={
                'create': {
                    'id': 'bcedehfiji',
                    'username': 'heffgjdei',
                    'email': 'dahihgbeb',
                    'designationId': 'bgheaejbcc',
                    'passwordHash': 'bfcgifeged',
                    'departmentId': 'jfiahhbae',
                    'dateOfJoining': datetime.datetime.utcnow(),
                    'statusId': 'bfbdafajcb',
                },
                'update': {
                    'username': 'heffgjdei',
                    'email': 'dahihgbeb',
                    'designationId': 'bgheaejbcc',
                    'passwordHash': 'bfcgifeged',
                    'departmentId': 'jfiahhbae',
                    'dateOfJoining': datetime.datetime.utcnow(),
                    'statusId': 'bfbdafajcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmployeeUpdateManyMutationInput,
        where: types.EmployeeWhereInput,
    ) -> int:
        """Update multiple Employee records

        Parameters
        ----------
        data
            Employee data to update the selected Employee records to
        where
            Filter to select the Employee records to update

        Returns
        -------
        int
            The total number of Employee records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Employee records
        total = await Employee.prisma().update_many(
            data={
                'departmentId': 'bdgjicijhb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeWhereInput] = None,
        cursor: Optional[types.EmployeeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Employee records present in the database

        Parameters
        ----------
        select
            Select the Employee fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Employee filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmployeeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Employee.prisma().count()

        # results: prisma.types.EmployeeCountAggregateOutput
        results = await Employee.prisma().count(
            select={
                '_all': True,
                'managerId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmployeeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeWhereInput] = None,
        cursor: Optional[types.EmployeeWhereUniqueInput] = None,
    ) -> types.EmployeeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmployeeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeWhereInput] = None,
        cursor: Optional[types.EmployeeWhereUniqueInput] = None,
    ) -> Union[int, types.EmployeeCountAggregateOutput]:
        """Count the number of Employee records present in the database

        Parameters
        ----------
        select
            Select the Employee fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Employee filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmployeeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Employee.prisma().count()

        # results: prisma.types.EmployeeCountAggregateOutput
        results = await Employee.prisma().count(
            select={
                '_all': True,
                'dateOfJoining': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmployeeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmployeeWhereInput] = None
    ) -> int:
        """Delete multiple Employee records.

        Parameters
        ----------
        where
            Optional Employee filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Employee records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Employee records
        total = await Employee.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmployeeScalarFieldKeys'],
        *,
        where: Optional['types.EmployeeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmployeeAvgAggregateInput'] = None,
        sum: Optional['types.EmployeeSumAggregateInput'] = None,
        min: Optional['types.EmployeeMinAggregateInput'] = None,
        max: Optional['types.EmployeeMaxAggregateInput'] = None,
        having: Optional['types.EmployeeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmployeeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmployeeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmployeeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmployeeGroupByOutput']:
        """Group Employee records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Employee fields to group records by
        where
            Employee filter to select records
        take
            Limit the maximum number of Employee records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmployeeGroupByOutput]
            A list of dictionaries representing the Employee record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Employee records by statusId values
        # and count how many records are in each group
        results = await Employee.prisma().group_by(
            ['statusId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmployeeRoleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmployeeRole]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmployeeRole.prisma().query_raw(
            'SELECT * FROM EmployeeRole WHERE id = $1',
            'bghifjdeia',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmployeeRole
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmployeeRole.prisma().query_first(
            'SELECT * FROM EmployeeRole WHERE employeeId = $1',
            'eadfcbbcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmployeeRoleCreateInput,
        include: Optional[types.EmployeeRoleInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmployeeRole record.

        Parameters
        ----------
        data
            EmployeeRole record data
        include
            Specifies which relations should be loaded on the returned EmployeeRole model

        Returns
        -------
        prisma.models.EmployeeRole
            The created EmployeeRole record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmployeeRole record from just the required fields
        employeerole = await EmployeeRole.prisma().create(
            data={
                # data to create a EmployeeRole record
                'employeeId': 'geihgahba',
                'roleId': 'gahdcdhbj',
                'assignedBy': 'begiijahea',
                'createdBy': 'gcjadjaaf',
                'updatedBy': 'bcbebgiaic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmployeeRoleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmployeeRole records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmployeeRole record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmployeeRole.prisma().create_many(
            data=[
                {
                    # data to create a EmployeeRole record
                    'employeeId': 'ijigbdcbj',
                    'roleId': 'gfidhicai',
                    'assignedBy': 'jfegcaafh',
                    'createdBy': 'bcbeiajjfa',
                    'updatedBy': 'baehicaajf',
                },
                {
                    # data to create a EmployeeRole record
                    'employeeId': 'bdachdeiga',
                    'roleId': 'ijdafccef',
                    'assignedBy': 'ciaaiddag',
                    'createdBy': 'fejggijff',
                    'updatedBy': 'hghjaaai',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmployeeRoleWhereUniqueInput,
        include: Optional[types.EmployeeRoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmployeeRole record.

        Parameters
        ----------
        where
            EmployeeRole filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmployeeRole model

        Returns
        -------
        prisma.models.EmployeeRole
            The deleted EmployeeRole record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeerole = await EmployeeRole.prisma().delete(
            where={
                'id': 'cajicjjdef',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmployeeRoleWhereUniqueInput,
        include: Optional[types.EmployeeRoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmployeeRole record.

        Parameters
        ----------
        where
            EmployeeRole filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmployeeRole model

        Returns
        -------
        prisma.models.EmployeeRole
            The found EmployeeRole record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeerole = await EmployeeRole.prisma().find_unique(
            where={
                'id': 'cefjaadec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmployeeRoleWhereUniqueInput,
        include: Optional[types.EmployeeRoleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmployeeRole record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmployeeRole filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmployeeRole model

        Returns
        -------
        prisma.models.EmployeeRole
            The found EmployeeRole record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeerole = await EmployeeRole.prisma().find_unique_or_raise(
            where={
                'id': 'ibbigdigd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeRoleWhereInput] = None,
        cursor: Optional[types.EmployeeRoleWhereUniqueInput] = None,
        include: Optional[types.EmployeeRoleInclude] = None,
        order: Optional[Union[types.EmployeeRoleOrderByInput, List[types.EmployeeRoleOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeRoleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmployeeRole records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmployeeRole records returned
        skip
            Ignore the first N results
        where
            EmployeeRole filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmployeeRole model
        order
            Order the returned EmployeeRole records by any field
        distinct
            Filter EmployeeRole records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmployeeRole]
            The list of all EmployeeRole records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmployeeRole records
        employeeroles = await EmployeeRole.prisma().find_many(take=10)

        # find the first 5 EmployeeRole records ordered by the roleId field
        employeeroles = await EmployeeRole.prisma().find_many(
            take=5,
            order={
                'roleId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeRoleWhereInput] = None,
        cursor: Optional[types.EmployeeRoleWhereUniqueInput] = None,
        include: Optional[types.EmployeeRoleInclude] = None,
        order: Optional[Union[types.EmployeeRoleOrderByInput, List[types.EmployeeRoleOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeRoleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmployeeRole record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmployeeRole filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmployeeRole model
        order
            Order the returned EmployeeRole records by any field
        distinct
            Filter EmployeeRole records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmployeeRole
            The first EmployeeRole record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmployeeRole record ordered by the assignedAt field
        employeerole = await EmployeeRole.prisma().find_first(
            skip=1,
            order={
                'assignedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeRoleWhereInput] = None,
        cursor: Optional[types.EmployeeRoleWhereUniqueInput] = None,
        include: Optional[types.EmployeeRoleInclude] = None,
        order: Optional[Union[types.EmployeeRoleOrderByInput, List[types.EmployeeRoleOrderByInput]]] = None,
        distinct: Optional[List[types.EmployeeRoleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmployeeRole record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmployeeRole filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmployeeRole model
        order
            Order the returned EmployeeRole records by any field
        distinct
            Filter EmployeeRole records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmployeeRole
            The first EmployeeRole record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmployeeRole record ordered by the assignedBy field
        employeerole = await EmployeeRole.prisma().find_first_or_raise(
            skip=1,
            order={
                'assignedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmployeeRoleUpdateInput,
        where: types.EmployeeRoleWhereUniqueInput,
        include: Optional[types.EmployeeRoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmployeeRole record.

        Parameters
        ----------
        data
            EmployeeRole record data specifying what to update
        where
            EmployeeRole filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmployeeRole model

        Returns
        -------
        prisma.models.EmployeeRole
            The updated EmployeeRole record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        employeerole = await EmployeeRole.prisma().update(
            where={
                'id': 'bdiiiabbii',
            },
            data={
                # data to update the EmployeeRole record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmployeeRoleWhereUniqueInput,
        data: types.EmployeeRoleUpsertInput,
        include: Optional[types.EmployeeRoleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmployeeRole filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmployeeRole model

        Returns
        -------
        prisma.models.EmployeeRole
            The created or updated EmployeeRole record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        employeerole = await EmployeeRole.prisma().upsert(
            where={
                'id': 'hfcfhhadh',
            },
            data={
                'create': {
                    'id': 'hfcfhhadh',
                    'employeeId': 'bdachdeiga',
                    'roleId': 'ijdafccef',
                    'assignedBy': 'ciaaiddag',
                    'createdBy': 'fejggijff',
                    'updatedBy': 'hghjaaai',
                },
                'update': {
                    'employeeId': 'bdachdeiga',
                    'roleId': 'ijdafccef',
                    'assignedBy': 'ciaaiddag',
                    'createdBy': 'fejggijff',
                    'updatedBy': 'hghjaaai',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmployeeRoleUpdateManyMutationInput,
        where: types.EmployeeRoleWhereInput,
    ) -> int:
        """Update multiple EmployeeRole records

        Parameters
        ----------
        data
            EmployeeRole data to update the selected EmployeeRole records to
        where
            Filter to select the EmployeeRole records to update

        Returns
        -------
        int
            The total number of EmployeeRole records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmployeeRole records
        total = await EmployeeRole.prisma().update_many(
            data={
                'revokedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeRoleWhereInput] = None,
        cursor: Optional[types.EmployeeRoleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmployeeRole records present in the database

        Parameters
        ----------
        select
            Select the EmployeeRole fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmployeeRole filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmployeeRoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmployeeRole.prisma().count()

        # results: prisma.types.EmployeeRoleCountAggregateOutput
        results = await EmployeeRole.prisma().count(
            select={
                '_all': True,
                'revokedBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmployeeRoleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeRoleWhereInput] = None,
        cursor: Optional[types.EmployeeRoleWhereUniqueInput] = None,
    ) -> types.EmployeeRoleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmployeeRoleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmployeeRoleWhereInput] = None,
        cursor: Optional[types.EmployeeRoleWhereUniqueInput] = None,
    ) -> Union[int, types.EmployeeRoleCountAggregateOutput]:
        """Count the number of EmployeeRole records present in the database

        Parameters
        ----------
        select
            Select the EmployeeRole fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmployeeRole filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmployeeRoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmployeeRole.prisma().count()

        # results: prisma.types.EmployeeRoleCountAggregateOutput
        results = await EmployeeRole.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmployeeRoleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmployeeRoleWhereInput] = None
    ) -> int:
        """Delete multiple EmployeeRole records.

        Parameters
        ----------
        where
            Optional EmployeeRole filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmployeeRole records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmployeeRole records
        total = await EmployeeRole.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmployeeRoleScalarFieldKeys'],
        *,
        where: Optional['types.EmployeeRoleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmployeeRoleAvgAggregateInput'] = None,
        sum: Optional['types.EmployeeRoleSumAggregateInput'] = None,
        min: Optional['types.EmployeeRoleMinAggregateInput'] = None,
        max: Optional['types.EmployeeRoleMaxAggregateInput'] = None,
        having: Optional['types.EmployeeRoleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmployeeRoleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmployeeRoleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmployeeRoleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmployeeRoleGroupByOutput']:
        """Group EmployeeRole records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmployeeRole fields to group records by
        where
            EmployeeRole filter to select records
        take
            Limit the maximum number of EmployeeRole records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmployeeRoleGroupByOutput]
            A list of dictionaries representing the EmployeeRole record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmployeeRole records by createdAt values
        # and count how many records are in each group
        results = await EmployeeRole.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WalletActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Wallet]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Wallet.prisma().query_raw(
            'SELECT * FROM Wallet WHERE id = $1',
            'bbihggdcji',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Wallet
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Wallet.prisma().query_first(
            'SELECT * FROM Wallet WHERE employeeId = $1',
            'hgjgibdgd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WalletCreateInput,
        include: Optional[types.WalletInclude] = None
    ) -> _PrismaModelT:
        """Create a new Wallet record.

        Parameters
        ----------
        data
            Wallet record data
        include
            Specifies which relations should be loaded on the returned Wallet model

        Returns
        -------
        prisma.models.Wallet
            The created Wallet record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Wallet record from just the required fields
        wallet = await Wallet.prisma().create(
            data={
                # data to create a Wallet record
                'employeeId': 'bcbecjfice',
                'createdBy': 'bacbebhjjd',
                'updatedBy': 'dfbfaddhe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WalletCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Wallet records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Wallet record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Wallet.prisma().create_many(
            data=[
                {
                    # data to create a Wallet record
                    'employeeId': 'bdcbbieibf',
                    'createdBy': 'dgjhdcggi',
                    'updatedBy': 'bbjbcdfabd',
                },
                {
                    # data to create a Wallet record
                    'employeeId': 'gchfgbcec',
                    'createdBy': 'bihcjfcjah',
                    'updatedBy': 'bhjdcicaii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WalletWhereUniqueInput,
        include: Optional[types.WalletInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Wallet record.

        Parameters
        ----------
        where
            Wallet filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Wallet model

        Returns
        -------
        prisma.models.Wallet
            The deleted Wallet record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wallet = await Wallet.prisma().delete(
            where={
                'id': 'bibedjhcej',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WalletWhereUniqueInput,
        include: Optional[types.WalletInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Wallet record.

        Parameters
        ----------
        where
            Wallet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Wallet model

        Returns
        -------
        prisma.models.Wallet
            The found Wallet record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wallet = await Wallet.prisma().find_unique(
            where={
                'id': 'bjcdajabfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WalletWhereUniqueInput,
        include: Optional[types.WalletInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Wallet record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Wallet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Wallet model

        Returns
        -------
        prisma.models.Wallet
            The found Wallet record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wallet = await Wallet.prisma().find_unique_or_raise(
            where={
                'id': 'bchhceeeff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WalletWhereInput] = None,
        cursor: Optional[types.WalletWhereUniqueInput] = None,
        include: Optional[types.WalletInclude] = None,
        order: Optional[Union[types.WalletOrderByInput, List[types.WalletOrderByInput]]] = None,
        distinct: Optional[List[types.WalletScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Wallet records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Wallet records returned
        skip
            Ignore the first N results
        where
            Wallet filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Wallet model
        order
            Order the returned Wallet records by any field
        distinct
            Filter Wallet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Wallet]
            The list of all Wallet records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Wallet records
        wallets = await Wallet.prisma().find_many(take=10)

        # find the first 5 Wallet records ordered by the availablePoints field
        wallets = await Wallet.prisma().find_many(
            take=5,
            order={
                'availablePoints': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WalletWhereInput] = None,
        cursor: Optional[types.WalletWhereUniqueInput] = None,
        include: Optional[types.WalletInclude] = None,
        order: Optional[Union[types.WalletOrderByInput, List[types.WalletOrderByInput]]] = None,
        distinct: Optional[List[types.WalletScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Wallet record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Wallet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Wallet model
        order
            Order the returned Wallet records by any field
        distinct
            Filter Wallet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Wallet
            The first Wallet record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Wallet record ordered by the redeemedPoints field
        wallet = await Wallet.prisma().find_first(
            skip=1,
            order={
                'redeemedPoints': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WalletWhereInput] = None,
        cursor: Optional[types.WalletWhereUniqueInput] = None,
        include: Optional[types.WalletInclude] = None,
        order: Optional[Union[types.WalletOrderByInput, List[types.WalletOrderByInput]]] = None,
        distinct: Optional[List[types.WalletScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Wallet record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Wallet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Wallet model
        order
            Order the returned Wallet records by any field
        distinct
            Filter Wallet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Wallet
            The first Wallet record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Wallet record ordered by the totalEarnedPoints field
        wallet = await Wallet.prisma().find_first_or_raise(
            skip=1,
            order={
                'totalEarnedPoints': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WalletUpdateInput,
        where: types.WalletWhereUniqueInput,
        include: Optional[types.WalletInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Wallet record.

        Parameters
        ----------
        data
            Wallet record data specifying what to update
        where
            Wallet filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Wallet model

        Returns
        -------
        prisma.models.Wallet
            The updated Wallet record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        wallet = await Wallet.prisma().update(
            where={
                'id': 'bbgaifhdaa',
            },
            data={
                # data to update the Wallet record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WalletWhereUniqueInput,
        data: types.WalletUpsertInput,
        include: Optional[types.WalletInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Wallet filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Wallet model

        Returns
        -------
        prisma.models.Wallet
            The created or updated Wallet record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        wallet = await Wallet.prisma().upsert(
            where={
                'id': 'dgbcdaegb',
            },
            data={
                'create': {
                    'id': 'dgbcdaegb',
                    'employeeId': 'gchfgbcec',
                    'createdBy': 'bihcjfcjah',
                    'updatedBy': 'bhjdcicaii',
                },
                'update': {
                    'employeeId': 'gchfgbcec',
                    'createdBy': 'bihcjfcjah',
                    'updatedBy': 'bhjdcicaii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WalletUpdateManyMutationInput,
        where: types.WalletWhereInput,
    ) -> int:
        """Update multiple Wallet records

        Parameters
        ----------
        data
            Wallet data to update the selected Wallet records to
        where
            Filter to select the Wallet records to update

        Returns
        -------
        int
            The total number of Wallet records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Wallet records
        total = await Wallet.prisma().update_many(
            data={
                'version': 1406511986
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WalletWhereInput] = None,
        cursor: Optional[types.WalletWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Wallet records present in the database

        Parameters
        ----------
        select
            Select the Wallet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Wallet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WalletCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Wallet.prisma().count()

        # results: prisma.types.WalletCountAggregateOutput
        results = await Wallet.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WalletCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WalletWhereInput] = None,
        cursor: Optional[types.WalletWhereUniqueInput] = None,
    ) -> types.WalletCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WalletCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WalletWhereInput] = None,
        cursor: Optional[types.WalletWhereUniqueInput] = None,
    ) -> Union[int, types.WalletCountAggregateOutput]:
        """Count the number of Wallet records present in the database

        Parameters
        ----------
        select
            Select the Wallet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Wallet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WalletCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Wallet.prisma().count()

        # results: prisma.types.WalletCountAggregateOutput
        results = await Wallet.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WalletCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WalletWhereInput] = None
    ) -> int:
        """Delete multiple Wallet records.

        Parameters
        ----------
        where
            Optional Wallet filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Wallet records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Wallet records
        total = await Wallet.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WalletScalarFieldKeys'],
        *,
        where: Optional['types.WalletWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WalletAvgAggregateInput'] = None,
        sum: Optional['types.WalletSumAggregateInput'] = None,
        min: Optional['types.WalletMinAggregateInput'] = None,
        max: Optional['types.WalletMaxAggregateInput'] = None,
        having: Optional['types.WalletScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WalletCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WalletScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WalletScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WalletGroupByOutput']:
        """Group Wallet records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Wallet fields to group records by
        where
            Wallet filter to select records
        take
            Limit the maximum number of Wallet records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WalletGroupByOutput]
            A list of dictionaries representing the Wallet record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Wallet records by updatedAt values
        # and count how many records are in each group
        results = await Wallet.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Transaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Transaction.prisma().query_raw(
            'SELECT * FROM Transaction WHERE id = $1',
            'beicihhijb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Transaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Transaction.prisma().query_first(
            'SELECT * FROM Transaction WHERE walletId = $1',
            'fgggcdcjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TransactionCreateInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Transaction record.

        Parameters
        ----------
        data
            Transaction record data
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created Transaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Transaction record from just the required fields
        transaction = await Transaction.prisma().create(
            data={
                # data to create a Transaction record
                'walletId': 'ccjbbjigf',
                'amount': 1750011070,
                'transactionTypeId': 'ebajedhhf',
                'statusId': 'jajacedge',
                'referenceNumber': 'hffgbabgf',
                'createdBy': 'biacbiieja',
                'updatedBy': 'cjejbgbff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Transaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Transaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Transaction.prisma().create_many(
            data=[
                {
                    # data to create a Transaction record
                    'walletId': 'fgeahddae',
                    'amount': 380648625,
                    'transactionTypeId': 'badagbgeha',
                    'statusId': 'ibgebbjch',
                    'referenceNumber': 'baieajjiee',
                    'createdBy': 'bahjhaccfd',
                    'updatedBy': 'hffhfabhi',
                },
                {
                    # data to create a Transaction record
                    'walletId': 'bbcigiadhb',
                    'amount': 259061104,
                    'transactionTypeId': 'bbbfhdidef',
                    'statusId': 'bdadhibhec',
                    'referenceNumber': 'bfhdjaiejf',
                    'createdBy': 'bbjfijjadg',
                    'updatedBy': 'hdjacbehh',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Transaction record.

        Parameters
        ----------
        where
            Transaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The deleted Transaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().delete(
            where={
                'id': 'bhcccbeaba',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Transaction record.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique(
            where={
                'id': 'bcgjbdgjdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Transaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique_or_raise(
            where={
                'id': 'fhdbhifae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Transaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N results
        where
            Transaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Transaction]
            The list of all Transaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Transaction records
        transactions = await Transaction.prisma().find_many(take=10)

        # find the first 5 Transaction records ordered by the amount field
        transactions = await Transaction.prisma().find_many(
            take=5,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Transaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the transactionTypeId field
        transaction = await Transaction.prisma().find_first(
            skip=1,
            order={
                'transactionTypeId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Transaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the statusId field
        transaction = await Transaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'statusId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TransactionUpdateInput,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Transaction record.

        Parameters
        ----------
        data
            Transaction record data specifying what to update
        where
            Transaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The updated Transaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transaction = await Transaction.prisma().update(
            where={
                'id': 'beeacgfcej',
            },
            data={
                # data to update the Transaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TransactionWhereUniqueInput,
        data: types.TransactionUpsertInput,
        include: Optional[types.TransactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Transaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created or updated Transaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().upsert(
            where={
                'id': 'bbifhdiicc',
            },
            data={
                'create': {
                    'id': 'bbifhdiicc',
                    'walletId': 'bbcigiadhb',
                    'amount': 259061104,
                    'transactionTypeId': 'bbbfhdidef',
                    'statusId': 'bdadhibhec',
                    'referenceNumber': 'bfhdjaiejf',
                    'createdBy': 'bbjfijjadg',
                    'updatedBy': 'hdjacbehh',
                },
                'update': {
                    'walletId': 'bbcigiadhb',
                    'amount': 259061104,
                    'transactionTypeId': 'bbbfhdidef',
                    'statusId': 'bdadhibhec',
                    'referenceNumber': 'bfhdjaiejf',
                    'createdBy': 'bbjfijjadg',
                    'updatedBy': 'hdjacbehh',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TransactionUpdateManyMutationInput,
        where: types.TransactionWhereInput,
    ) -> int:
        """Update multiple Transaction records

        Parameters
        ----------
        data
            Transaction data to update the selected Transaction records to
        where
            Filter to select the Transaction records to update

        Returns
        -------
        int
            The total number of Transaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Transaction records
        total = await Transaction.prisma().update_many(
            data={
                'description': 'bgjeccejad'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'referenceNumber': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TransactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> types.TransactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TransactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> Union[int, types.TransactionCountAggregateOutput]:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'transactionAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TransactionWhereInput] = None
    ) -> int:
        """Delete multiple Transaction records.

        Parameters
        ----------
        where
            Optional Transaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Transaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Transaction records
        total = await Transaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TransactionScalarFieldKeys'],
        *,
        where: Optional['types.TransactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransactionAvgAggregateInput'] = None,
        sum: Optional['types.TransactionSumAggregateInput'] = None,
        min: Optional['types.TransactionMinAggregateInput'] = None,
        max: Optional['types.TransactionMaxAggregateInput'] = None,
        having: Optional['types.TransactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransactionGroupByOutput']:
        """Group Transaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Transaction fields to group records by
        where
            Transaction filter to select records
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransactionGroupByOutput]
            A list of dictionaries representing the Transaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Transaction records by createdAt values
        # and count how many records are in each group
        results = await Transaction.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RewardHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RewardHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RewardHistory.prisma().query_raw(
            'SELECT * FROM RewardHistory WHERE id = $1',
            'bjagdgabbg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RewardHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RewardHistory.prisma().query_first(
            'SELECT * FROM RewardHistory WHERE walletId = $1',
            'bjbbcffdij',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RewardHistoryCreateInput,
        include: Optional[types.RewardHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new RewardHistory record.

        Parameters
        ----------
        data
            RewardHistory record data
        include
            Specifies which relations should be loaded on the returned RewardHistory model

        Returns
        -------
        prisma.models.RewardHistory
            The created RewardHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RewardHistory record from just the required fields
        rewardhistory = await RewardHistory.prisma().create(
            data={
                # data to create a RewardHistory record
                'walletId': 'begcgchdi',
                'catalogId': 'bhbjceagbb',
                'grantedBy': 'bjeifffjdg',
                'points': 1383253593,
                'createdBy': 'dfeggejja',
                'updatedBy': 'gehbgghbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RewardHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RewardHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RewardHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RewardHistory.prisma().create_many(
            data=[
                {
                    # data to create a RewardHistory record
                    'walletId': 'dfhaijeie',
                    'catalogId': 'gbcdjgicb',
                    'grantedBy': 'biaibdagac',
                    'points': 1151748123,
                    'createdBy': 'hiagajie',
                    'updatedBy': 'eeejidbif',
                },
                {
                    # data to create a RewardHistory record
                    'walletId': 'efgbahec',
                    'catalogId': 'hgjaiebfb',
                    'grantedBy': 'bddefjjabc',
                    'points': 1116761037,
                    'createdBy': 'bbhcgagaic',
                    'updatedBy': 'ddaabegbb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RewardHistoryWhereUniqueInput,
        include: Optional[types.RewardHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RewardHistory record.

        Parameters
        ----------
        where
            RewardHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RewardHistory model

        Returns
        -------
        prisma.models.RewardHistory
            The deleted RewardHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardhistory = await RewardHistory.prisma().delete(
            where={
                'id': 'bhgibfgbbc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RewardHistoryWhereUniqueInput,
        include: Optional[types.RewardHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RewardHistory record.

        Parameters
        ----------
        where
            RewardHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RewardHistory model

        Returns
        -------
        prisma.models.RewardHistory
            The found RewardHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardhistory = await RewardHistory.prisma().find_unique(
            where={
                'id': 'hbgcihef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RewardHistoryWhereUniqueInput,
        include: Optional[types.RewardHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RewardHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RewardHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RewardHistory model

        Returns
        -------
        prisma.models.RewardHistory
            The found RewardHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardhistory = await RewardHistory.prisma().find_unique_or_raise(
            where={
                'id': 'ffhgghde',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardHistoryWhereInput] = None,
        cursor: Optional[types.RewardHistoryWhereUniqueInput] = None,
        include: Optional[types.RewardHistoryInclude] = None,
        order: Optional[Union[types.RewardHistoryOrderByInput, List[types.RewardHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.RewardHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RewardHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RewardHistory records returned
        skip
            Ignore the first N results
        where
            RewardHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardHistory model
        order
            Order the returned RewardHistory records by any field
        distinct
            Filter RewardHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RewardHistory]
            The list of all RewardHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RewardHistory records
        rewardhistorys = await RewardHistory.prisma().find_many(take=10)

        # find the first 5 RewardHistory records ordered by the catalogId field
        rewardhistorys = await RewardHistory.prisma().find_many(
            take=5,
            order={
                'catalogId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RewardHistoryWhereInput] = None,
        cursor: Optional[types.RewardHistoryWhereUniqueInput] = None,
        include: Optional[types.RewardHistoryInclude] = None,
        order: Optional[Union[types.RewardHistoryOrderByInput, List[types.RewardHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.RewardHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RewardHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RewardHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardHistory model
        order
            Order the returned RewardHistory records by any field
        distinct
            Filter RewardHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RewardHistory
            The first RewardHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RewardHistory record ordered by the grantedBy field
        rewardhistory = await RewardHistory.prisma().find_first(
            skip=1,
            order={
                'grantedBy': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RewardHistoryWhereInput] = None,
        cursor: Optional[types.RewardHistoryWhereUniqueInput] = None,
        include: Optional[types.RewardHistoryInclude] = None,
        order: Optional[Union[types.RewardHistoryOrderByInput, List[types.RewardHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.RewardHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RewardHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RewardHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RewardHistory model
        order
            Order the returned RewardHistory records by any field
        distinct
            Filter RewardHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RewardHistory
            The first RewardHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RewardHistory record ordered by the points field
        rewardhistory = await RewardHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'points': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RewardHistoryUpdateInput,
        where: types.RewardHistoryWhereUniqueInput,
        include: Optional[types.RewardHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RewardHistory record.

        Parameters
        ----------
        data
            RewardHistory record data specifying what to update
        where
            RewardHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RewardHistory model

        Returns
        -------
        prisma.models.RewardHistory
            The updated RewardHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rewardhistory = await RewardHistory.prisma().update(
            where={
                'id': 'ibcadcejf',
            },
            data={
                # data to update the RewardHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RewardHistoryWhereUniqueInput,
        data: types.RewardHistoryUpsertInput,
        include: Optional[types.RewardHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RewardHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RewardHistory model

        Returns
        -------
        prisma.models.RewardHistory
            The created or updated RewardHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rewardhistory = await RewardHistory.prisma().upsert(
            where={
                'id': 'bdcdfgccdg',
            },
            data={
                'create': {
                    'id': 'bdcdfgccdg',
                    'walletId': 'efgbahec',
                    'catalogId': 'hgjaiebfb',
                    'grantedBy': 'bddefjjabc',
                    'points': 1116761037,
                    'createdBy': 'bbhcgagaic',
                    'updatedBy': 'ddaabegbb',
                },
                'update': {
                    'walletId': 'efgbahec',
                    'catalogId': 'hgjaiebfb',
                    'grantedBy': 'bddefjjabc',
                    'points': 1116761037,
                    'createdBy': 'bbhcgagaic',
                    'updatedBy': 'ddaabegbb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RewardHistoryUpdateManyMutationInput,
        where: types.RewardHistoryWhereInput,
    ) -> int:
        """Update multiple RewardHistory records

        Parameters
        ----------
        data
            RewardHistory data to update the selected RewardHistory records to
        where
            Filter to select the RewardHistory records to update

        Returns
        -------
        int
            The total number of RewardHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RewardHistory records
        total = await RewardHistory.prisma().update_many(
            data={
                'comment': 'edhjgdfh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardHistoryWhereInput] = None,
        cursor: Optional[types.RewardHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RewardHistory records present in the database

        Parameters
        ----------
        select
            Select the RewardHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RewardHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RewardHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RewardHistory.prisma().count()

        # results: prisma.types.RewardHistoryCountAggregateOutput
        results = await RewardHistory.prisma().count(
            select={
                '_all': True,
                'grantedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RewardHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardHistoryWhereInput] = None,
        cursor: Optional[types.RewardHistoryWhereUniqueInput] = None,
    ) -> types.RewardHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RewardHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RewardHistoryWhereInput] = None,
        cursor: Optional[types.RewardHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.RewardHistoryCountAggregateOutput]:
        """Count the number of RewardHistory records present in the database

        Parameters
        ----------
        select
            Select the RewardHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RewardHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RewardHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RewardHistory.prisma().count()

        # results: prisma.types.RewardHistoryCountAggregateOutput
        results = await RewardHistory.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RewardHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RewardHistoryWhereInput] = None
    ) -> int:
        """Delete multiple RewardHistory records.

        Parameters
        ----------
        where
            Optional RewardHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RewardHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RewardHistory records
        total = await RewardHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RewardHistoryScalarFieldKeys'],
        *,
        where: Optional['types.RewardHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RewardHistoryAvgAggregateInput'] = None,
        sum: Optional['types.RewardHistorySumAggregateInput'] = None,
        min: Optional['types.RewardHistoryMinAggregateInput'] = None,
        max: Optional['types.RewardHistoryMaxAggregateInput'] = None,
        having: Optional['types.RewardHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RewardHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RewardHistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RewardHistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RewardHistoryGroupByOutput']:
        """Group RewardHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RewardHistory fields to group records by
        where
            RewardHistory filter to select records
        take
            Limit the maximum number of RewardHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RewardHistoryGroupByOutput]
            A list of dictionaries representing the RewardHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RewardHistory records by createdBy values
        # and count how many records are in each group
        results = await RewardHistory.prisma().group_by(
            ['createdBy'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReviewActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Review]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Review.prisma().query_raw(
            'SELECT * FROM Review WHERE id = $1',
            'bdeffdadda',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Review
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Review.prisma().query_first(
            'SELECT * FROM Review WHERE reviewerId = $1',
            'bjgfdihchf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReviewCreateInput,
        include: Optional[types.ReviewInclude] = None
    ) -> _PrismaModelT:
        """Create a new Review record.

        Parameters
        ----------
        data
            Review record data
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The created Review record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Review record from just the required fields
        review = await Review.prisma().create(
            data={
                # data to create a Review record
                'reviewerId': 'iaeihdeei',
                'receiverId': 'bfggejgfbd',
                'rating': 850004390,
                'comment': 'cbajdjjabf',
                'statusId': 'bcicggedea',
                'createdBy': 'cebcdadjh',
                'updatedBy': 'ehfigdgac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReviewCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Review records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Review record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Review.prisma().create_many(
            data=[
                {
                    # data to create a Review record
                    'reviewerId': 'bhbgccijjf',
                    'receiverId': 'bigjhdgbjc',
                    'rating': 1585341753,
                    'comment': 'cjchbjde',
                    'statusId': 'bfiibjcehj',
                    'createdBy': 'ijieafghg',
                    'updatedBy': 'hhhegahcf',
                },
                {
                    # data to create a Review record
                    'reviewerId': 'edhijefdi',
                    'receiverId': 'djddecjhb',
                    'rating': 163829784,
                    'comment': 'ceibfcgij',
                    'statusId': 'debhbfada',
                    'createdBy': 'bgjchggecd',
                    'updatedBy': 'igggcfjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Review record.

        Parameters
        ----------
        where
            Review filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The deleted Review record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().delete(
            where={
                'id': 'bgjhijffjh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Review record.

        Parameters
        ----------
        where
            Review filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The found Review record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().find_unique(
            where={
                'id': 'bcigdhache',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Review record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Review filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The found Review record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().find_unique_or_raise(
            where={
                'id': 'igefhgdhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Review records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Review records returned
        skip
            Ignore the first N results
        where
            Review filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Review]
            The list of all Review records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Review records
        reviews = await Review.prisma().find_many(take=10)

        # find the first 5 Review records ordered by the receiverId field
        reviews = await Review.prisma().find_many(
            take=5,
            order={
                'receiverId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Review record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Review filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Review
            The first Review record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Review record ordered by the rating field
        review = await Review.prisma().find_first(
            skip=1,
            order={
                'rating': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Review record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Review filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Review
            The first Review record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Review record ordered by the comment field
        review = await Review.prisma().find_first_or_raise(
            skip=1,
            order={
                'comment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReviewUpdateInput,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Review record.

        Parameters
        ----------
        data
            Review record data specifying what to update
        where
            Review filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The updated Review record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        review = await Review.prisma().update(
            where={
                'id': 'ejbiifbae',
            },
            data={
                # data to update the Review record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReviewWhereUniqueInput,
        data: types.ReviewUpsertInput,
        include: Optional[types.ReviewInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Review filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The created or updated Review record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().upsert(
            where={
                'id': 'djcfgedjd',
            },
            data={
                'create': {
                    'id': 'djcfgedjd',
                    'reviewerId': 'edhijefdi',
                    'receiverId': 'djddecjhb',
                    'rating': 163829784,
                    'comment': 'ceibfcgij',
                    'statusId': 'debhbfada',
                    'createdBy': 'bgjchggecd',
                    'updatedBy': 'igggcfjg',
                },
                'update': {
                    'reviewerId': 'edhijefdi',
                    'receiverId': 'djddecjhb',
                    'rating': 163829784,
                    'comment': 'ceibfcgij',
                    'statusId': 'debhbfada',
                    'createdBy': 'bgjchggecd',
                    'updatedBy': 'igggcfjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReviewUpdateManyMutationInput,
        where: types.ReviewWhereInput,
    ) -> int:
        """Update multiple Review records

        Parameters
        ----------
        data
            Review data to update the selected Review records to
        where
            Filter to select the Review records to update

        Returns
        -------
        int
            The total number of Review records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Review records
        total = await Review.prisma().update_many(
            data={
                'imageUrl': 'bdbjcdegag'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Review records present in the database

        Parameters
        ----------
        select
            Select the Review fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Review filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Review.prisma().count()

        # results: prisma.types.ReviewCountAggregateOutput
        results = await Review.prisma().count(
            select={
                '_all': True,
                'videoUrl': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReviewCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> types.ReviewCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReviewCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> Union[int, types.ReviewCountAggregateOutput]:
        """Count the number of Review records present in the database

        Parameters
        ----------
        select
            Select the Review fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Review filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Review.prisma().count()

        # results: prisma.types.ReviewCountAggregateOutput
        results = await Review.prisma().count(
            select={
                '_all': True,
                'statusId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReviewCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReviewWhereInput] = None
    ) -> int:
        """Delete multiple Review records.

        Parameters
        ----------
        where
            Optional Review filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Review records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Review records
        total = await Review.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReviewScalarFieldKeys'],
        *,
        where: Optional['types.ReviewWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReviewAvgAggregateInput'] = None,
        sum: Optional['types.ReviewSumAggregateInput'] = None,
        min: Optional['types.ReviewMinAggregateInput'] = None,
        max: Optional['types.ReviewMaxAggregateInput'] = None,
        having: Optional['types.ReviewScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReviewCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReviewScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReviewScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReviewGroupByOutput']:
        """Group Review records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Review fields to group records by
        where
            Review filter to select records
        take
            Limit the maximum number of Review records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReviewGroupByOutput]
            A list of dictionaries representing the Review record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Review records by reviewAt values
        # and count how many records are in each group
        results = await Review.prisma().group_by(
            ['reviewAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuditLog.prisma().query_raw(
            'SELECT * FROM AuditLog WHERE id = $1',
            'hbchfebch',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuditLog.prisma().query_first(
            'SELECT * FROM AuditLog WHERE tableName = $1',
            'bcjjffegfc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuditLogCreateInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuditLog record from just the required fields
        auditlog = await AuditLog.prisma().create(
            data={
                # data to create a AuditLog record
                'tableName': 'cahaeaicjd',
                'recordId': 'ibbjaacbi',
                'operationType': 'djgacbcch',
                'performedBy': 'geeeegace',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a AuditLog record
                    'tableName': 'bbgdigchd',
                    'recordId': 'dajcifgdi',
                    'operationType': 'ccedhdbj',
                    'performedBy': 'bjaabjjjce',
                },
                {
                    # data to create a AuditLog record
                    'tableName': 'cafhdcdcjd',
                    'recordId': 'bdeebbhbdi',
                    'operationType': 'cafcbdchah',
                    'performedBy': 'bdffbehbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The deleted AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().delete(
            where={
                'id': 'ieahjgeb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique(
            where={
                'id': 'hfeeddceg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'dbecgbbid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N results
        where
            AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuditLog]
            The list of all AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuditLog records
        auditlogs = await AuditLog.prisma().find_many(take=10)

        # find the first 5 AuditLog records ordered by the recordId field
        auditlogs = await AuditLog.prisma().find_many(
            take=5,
            order={
                'recordId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the operationType field
        auditlog = await AuditLog.prisma().find_first(
            skip=1,
            order={
                'operationType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the oldValues field
        auditlog = await AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'oldValues': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuditLogUpdateInput,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data specifying what to update
        where
            AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The updated AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().update(
            where={
                'id': 'cchghigae',
            },
            data={
                # data to update the AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuditLogWhereUniqueInput,
        data: types.AuditLogUpsertInput,
        include: Optional[types.AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created or updated AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().upsert(
            where={
                'id': 'ecdjjjhab',
            },
            data={
                'create': {
                    'id': 'ecdjjjhab',
                    'tableName': 'cafhdcdcjd',
                    'recordId': 'bdeebbhbdi',
                    'operationType': 'cafcbdchah',
                    'performedBy': 'bdffbehbae',
                },
                'update': {
                    'tableName': 'cafhdcdcjd',
                    'recordId': 'bdeebbhbdi',
                    'operationType': 'cafcbdchah',
                    'performedBy': 'bdffbehbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuditLogUpdateManyMutationInput,
        where: types.AuditLogWhereInput,
    ) -> int:
        """Update multiple AuditLog records

        Parameters
        ----------
        data
            AuditLog data to update the selected AuditLog records to
        where
            Filter to select the AuditLog records to update

        Returns
        -------
        int
            The total number of AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuditLog records
        total = await AuditLog.prisma().update_many(
            data={
                'newValues': Json({'biachfede': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'performedBy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> types.AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.AuditLogCountAggregateOutput]:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'performedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple AuditLog records.

        Parameters
        ----------
        where
            Optional AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuditLog records
        total = await AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.AuditLogSumAggregateInput'] = None,
        min: Optional['types.AuditLogMinAggregateInput'] = None,
        max: Optional['types.AuditLogMaxAggregateInput'] = None,
        having: Optional['types.AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuditLogGroupByOutput']:
        """Group AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuditLog fields to group records by
        where
            AuditLog filter to select records
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuditLogGroupByOutput]
            A list of dictionaries representing the AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuditLog records by ipAddress values
        # and count how many records are in each group
        results = await AuditLog.prisma().group_by(
            ['ipAddress'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class refresh_tokensActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: 'Client', model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.refresh_tokens]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await refresh_tokens.prisma().query_raw(
            'SELECT * FROM refresh_tokens WHERE token_id = $1',
            'fhgaibff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.refresh_tokens
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await refresh_tokens.prisma().query_first(
            'SELECT * FROM refresh_tokens WHERE token_hash = $1',
            'cadajbcbca',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.refresh_tokensCreateInput,
        include: Optional[types.refresh_tokensInclude] = None
    ) -> _PrismaModelT:
        """Create a new refresh_tokens record.

        Parameters
        ----------
        data
            refresh_tokens record data
        include
            Specifies which relations should be loaded on the returned refresh_tokens model

        Returns
        -------
        prisma.models.refresh_tokens
            The created refresh_tokens record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a refresh_tokens record from just the required fields
        refresh_tokens = await refresh_tokens.prisma().create(
            data={
                # data to create a refresh_tokens record
                'token_hash': 'bjheigfcdd',
                'employee_id': 'bjejigcdcg',
                'expires_at': datetime.datetime.utcnow(),
                'updated_at': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.refresh_tokensCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple refresh_tokens records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of refresh_tokens record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await refresh_tokens.prisma().create_many(
            data=[
                {
                    # data to create a refresh_tokens record
                    'token_hash': 'bifiiibcah',
                    'employee_id': 'dbjibjdaa',
                    'expires_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
                {
                    # data to create a refresh_tokens record
                    'token_hash': 'dgijbdiaf',
                    'employee_id': 'begfaigba',
                    'expires_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.refresh_tokensWhereUniqueInput,
        include: Optional[types.refresh_tokensInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single refresh_tokens record.

        Parameters
        ----------
        where
            refresh_tokens filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned refresh_tokens model

        Returns
        -------
        prisma.models.refresh_tokens
            The deleted refresh_tokens record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refresh_tokens = await refresh_tokens.prisma().delete(
            where={
                'token_id': 'bdjiafcgjb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.refresh_tokensWhereUniqueInput,
        include: Optional[types.refresh_tokensInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique refresh_tokens record.

        Parameters
        ----------
        where
            refresh_tokens filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned refresh_tokens model

        Returns
        -------
        prisma.models.refresh_tokens
            The found refresh_tokens record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refresh_tokens = await refresh_tokens.prisma().find_unique(
            where={
                'token_id': 'bficecgcfg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.refresh_tokensWhereUniqueInput,
        include: Optional[types.refresh_tokensInclude] = None
    ) -> _PrismaModelT:
        """Find a unique refresh_tokens record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            refresh_tokens filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned refresh_tokens model

        Returns
        -------
        prisma.models.refresh_tokens
            The found refresh_tokens record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refresh_tokens = await refresh_tokens.prisma().find_unique_or_raise(
            where={
                'token_id': 'cbjjeedcj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.refresh_tokensWhereInput] = None,
        cursor: Optional[types.refresh_tokensWhereUniqueInput] = None,
        include: Optional[types.refresh_tokensInclude] = None,
        order: Optional[Union[types.refresh_tokensOrderByInput, List[types.refresh_tokensOrderByInput]]] = None,
        distinct: Optional[List[types.refresh_tokensScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple refresh_tokens records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of refresh_tokens records returned
        skip
            Ignore the first N results
        where
            refresh_tokens filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned refresh_tokens model
        order
            Order the returned refresh_tokens records by any field
        distinct
            Filter refresh_tokens records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.refresh_tokens]
            The list of all refresh_tokens records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 refresh_tokens records
        refresh_tokens = await refresh_tokens.prisma().find_many(take=10)

        # find the first 5 refresh_tokens records ordered by the employee_id field
        refresh_tokens = await refresh_tokens.prisma().find_many(
            take=5,
            order={
                'employee_id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.refresh_tokensWhereInput] = None,
        cursor: Optional[types.refresh_tokensWhereUniqueInput] = None,
        include: Optional[types.refresh_tokensInclude] = None,
        order: Optional[Union[types.refresh_tokensOrderByInput, List[types.refresh_tokensOrderByInput]]] = None,
        distinct: Optional[List[types.refresh_tokensScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single refresh_tokens record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            refresh_tokens filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned refresh_tokens model
        order
            Order the returned refresh_tokens records by any field
        distinct
            Filter refresh_tokens records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.refresh_tokens
            The first refresh_tokens record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second refresh_tokens record ordered by the expires_at field
        refresh_tokens = await refresh_tokens.prisma().find_first(
            skip=1,
            order={
                'expires_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.refresh_tokensWhereInput] = None,
        cursor: Optional[types.refresh_tokensWhereUniqueInput] = None,
        include: Optional[types.refresh_tokensInclude] = None,
        order: Optional[Union[types.refresh_tokensOrderByInput, List[types.refresh_tokensOrderByInput]]] = None,
        distinct: Optional[List[types.refresh_tokensScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single refresh_tokens record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            refresh_tokens filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned refresh_tokens model
        order
            Order the returned refresh_tokens records by any field
        distinct
            Filter refresh_tokens records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.refresh_tokens
            The first refresh_tokens record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second refresh_tokens record ordered by the revoked_at field
        refresh_tokens = await refresh_tokens.prisma().find_first_or_raise(
            skip=1,
            order={
                'revoked_at': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.refresh_tokensUpdateInput,
        where: types.refresh_tokensWhereUniqueInput,
        include: Optional[types.refresh_tokensInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single refresh_tokens record.

        Parameters
        ----------
        data
            refresh_tokens record data specifying what to update
        where
            refresh_tokens filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned refresh_tokens model

        Returns
        -------
        prisma.models.refresh_tokens
            The updated refresh_tokens record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        refresh_tokens = await refresh_tokens.prisma().update(
            where={
                'token_id': 'dedgbbhja',
            },
            data={
                # data to update the refresh_tokens record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.refresh_tokensWhereUniqueInput,
        data: types.refresh_tokensUpsertInput,
        include: Optional[types.refresh_tokensInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            refresh_tokens filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned refresh_tokens model

        Returns
        -------
        prisma.models.refresh_tokens
            The created or updated refresh_tokens record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        refresh_tokens = await refresh_tokens.prisma().upsert(
            where={
                'token_id': 'cabiahchj',
            },
            data={
                'create': {
                    'token_id': 'cabiahchj',
                    'token_hash': 'dgijbdiaf',
                    'employee_id': 'begfaigba',
                    'expires_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
                'update': {
                    'token_hash': 'dgijbdiaf',
                    'employee_id': 'begfaigba',
                    'expires_at': datetime.datetime.utcnow(),
                    'updated_at': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.refresh_tokensUpdateManyMutationInput,
        where: types.refresh_tokensWhereInput,
    ) -> int:
        """Update multiple refresh_tokens records

        Parameters
        ----------
        data
            refresh_tokens data to update the selected refresh_tokens records to
        where
            Filter to select the refresh_tokens records to update

        Returns
        -------
        int
            The total number of refresh_tokens records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all refresh_tokens records
        total = await refresh_tokens.prisma().update_many(
            data={
                'replaced_by_token': 'cgbeccfce'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.refresh_tokensWhereInput] = None,
        cursor: Optional[types.refresh_tokensWhereUniqueInput] = None,
    ) -> int:
        """Count the number of refresh_tokens records present in the database

        Parameters
        ----------
        select
            Select the refresh_tokens fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            refresh_tokens filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.refresh_tokensCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await refresh_tokens.prisma().count()

        # results: prisma.types.refresh_tokensCountAggregateOutput
        results = await refresh_tokens.prisma().count(
            select={
                '_all': True,
                'created_at': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.refresh_tokensCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.refresh_tokensWhereInput] = None,
        cursor: Optional[types.refresh_tokensWhereUniqueInput] = None,
    ) -> types.refresh_tokensCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.refresh_tokensCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.refresh_tokensWhereInput] = None,
        cursor: Optional[types.refresh_tokensWhereUniqueInput] = None,
    ) -> Union[int, types.refresh_tokensCountAggregateOutput]:
        """Count the number of refresh_tokens records present in the database

        Parameters
        ----------
        select
            Select the refresh_tokens fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            refresh_tokens filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.refresh_tokensCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await refresh_tokens.prisma().count()

        # results: prisma.types.refresh_tokensCountAggregateOutput
        results = await refresh_tokens.prisma().count(
            select={
                '_all': True,
                'updated_at': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.refresh_tokensCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.refresh_tokensWhereInput] = None
    ) -> int:
        """Delete multiple refresh_tokens records.

        Parameters
        ----------
        where
            Optional refresh_tokens filter to find the records to be deleted

        Returns
        -------
        int
            The total number of refresh_tokens records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all refresh_tokens records
        total = await refresh_tokens.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.refresh_tokensScalarFieldKeys'],
        *,
        where: Optional['types.refresh_tokensWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.refresh_tokensAvgAggregateInput'] = None,
        sum: Optional['types.refresh_tokensSumAggregateInput'] = None,
        min: Optional['types.refresh_tokensMinAggregateInput'] = None,
        max: Optional['types.refresh_tokensMaxAggregateInput'] = None,
        having: Optional['types.refresh_tokensScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.refresh_tokensCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.refresh_tokensScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.refresh_tokensScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.refresh_tokensGroupByOutput']:
        """Group refresh_tokens records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar refresh_tokens fields to group records by
        where
            refresh_tokens filter to select records
        take
            Limit the maximum number of refresh_tokens records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.refresh_tokensGroupByOutput]
            A list of dictionaries representing the refresh_tokens record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group refresh_tokens records by token_id values
        # and count how many records are in each group
        results = await refresh_tokens.prisma().group_by(
            ['token_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models