# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from .builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class StatusMaster(bases.BaseStatusMaster):
    """Represents a StatusMaster record"""

    id: _str
    statusCode: _str
    statusName: _str
    description: Optional[_str] = None
    entityType: _str
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    employees: Optional[List['models.Employee']] = None
    reviews: Optional[List['models.Review']] = None
    createdByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    transactions: Optional[List['models.Transaction']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.StatusMasterKeys']] = None,
        exclude: Optional[Iterable['types.StatusMasterKeys']] = None,
        required: Optional[Iterable['types.StatusMasterKeys']] = None,
        optional: Optional[Iterable['types.StatusMasterKeys']] = None,
        relations: Optional[Mapping['types.StatusMasterRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.StatusMasterKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _StatusMaster_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _StatusMaster_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _StatusMaster_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _StatusMaster_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _StatusMaster_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _StatusMaster_relational_fields:
                        raise errors.UnknownRelationalFieldError('StatusMaster', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid StatusMaster / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'StatusMaster',
            }
        )
        _created_partial_types.add(name)


class Designation(bases.BaseDesignation):
    """Represents a Designation record"""

    id: _str
    designationName: _str
    designationCode: _str
    level: _int
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    createdByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    employees: Optional[List['models.Employee']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DesignationKeys']] = None,
        exclude: Optional[Iterable['types.DesignationKeys']] = None,
        required: Optional[Iterable['types.DesignationKeys']] = None,
        optional: Optional[Iterable['types.DesignationKeys']] = None,
        relations: Optional[Mapping['types.DesignationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DesignationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Designation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Designation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Designation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Designation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Designation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Designation_relational_fields:
                        raise errors.UnknownRelationalFieldError('Designation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Designation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Designation',
            }
        )
        _created_partial_types.add(name)


class DepartmentType(bases.BaseDepartmentType):
    """Represents a DepartmentType record"""

    id: _str
    typeName: _str
    typeCode: _str
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    createdByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    departments: Optional[List['models.Department']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DepartmentTypeKeys']] = None,
        exclude: Optional[Iterable['types.DepartmentTypeKeys']] = None,
        required: Optional[Iterable['types.DepartmentTypeKeys']] = None,
        optional: Optional[Iterable['types.DepartmentTypeKeys']] = None,
        relations: Optional[Mapping['types.DepartmentTypeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DepartmentTypeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _DepartmentType_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _DepartmentType_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _DepartmentType_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _DepartmentType_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _DepartmentType_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _DepartmentType_relational_fields:
                        raise errors.UnknownRelationalFieldError('DepartmentType', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid DepartmentType / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'DepartmentType',
            }
        )
        _created_partial_types.add(name)


class Department(bases.BaseDepartment):
    """Represents a Department record"""

    id: _str
    departmentName: _str
    departmentCode: _str
    departmentTypeId: _str
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    createdByEmployee: Optional['models.Employee'] = None
    departmentType: Optional['models.DepartmentType'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    employees: Optional[List['models.Employee']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DepartmentKeys']] = None,
        exclude: Optional[Iterable['types.DepartmentKeys']] = None,
        required: Optional[Iterable['types.DepartmentKeys']] = None,
        optional: Optional[Iterable['types.DepartmentKeys']] = None,
        relations: Optional[Mapping['types.DepartmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DepartmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Department_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Department_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Department_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Department_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Department_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Department_relational_fields:
                        raise errors.UnknownRelationalFieldError('Department', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Department / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Department',
            }
        )
        _created_partial_types.add(name)


class Role(bases.BaseRole):
    """Represents a Role record"""

    id: _str
    roleName: _str
    roleCode: _str
    description: Optional[_str] = None
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    employeeRoles: Optional[List['models.EmployeeRole']] = None
    createdByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RoleKeys']] = None,
        exclude: Optional[Iterable['types.RoleKeys']] = None,
        required: Optional[Iterable['types.RoleKeys']] = None,
        optional: Optional[Iterable['types.RoleKeys']] = None,
        relations: Optional[Mapping['types.RoleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RoleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Role_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Role_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Role_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Role_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Role_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Role_relational_fields:
                        raise errors.UnknownRelationalFieldError('Role', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Role / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Role',
            }
        )
        _created_partial_types.add(name)


class TransactionType(bases.BaseTransactionType):
    """Represents a TransactionType record"""

    id: _str
    typeName: _str
    typeCode: _str
    description: Optional[_str] = None
    isCredit: _bool
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    createdByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    transactions: Optional[List['models.Transaction']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TransactionTypeKeys']] = None,
        exclude: Optional[Iterable['types.TransactionTypeKeys']] = None,
        required: Optional[Iterable['types.TransactionTypeKeys']] = None,
        optional: Optional[Iterable['types.TransactionTypeKeys']] = None,
        relations: Optional[Mapping['types.TransactionTypeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TransactionTypeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TransactionType_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TransactionType_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TransactionType_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TransactionType_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TransactionType_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TransactionType_relational_fields:
                        raise errors.UnknownRelationalFieldError('TransactionType', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TransactionType / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TransactionType',
            }
        )
        _created_partial_types.add(name)


class RewardCategory(bases.BaseRewardCategory):
    """Represents a RewardCategory record"""

    id: _str
    categoryName: _str
    categoryCode: _str
    description: Optional[_str] = None
    isActive: _bool
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    rewardCatalog: Optional[List['models.RewardCatalog']] = None
    createdByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RewardCategoryKeys']] = None,
        exclude: Optional[Iterable['types.RewardCategoryKeys']] = None,
        required: Optional[Iterable['types.RewardCategoryKeys']] = None,
        optional: Optional[Iterable['types.RewardCategoryKeys']] = None,
        relations: Optional[Mapping['types.RewardCategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RewardCategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RewardCategory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RewardCategory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RewardCategory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RewardCategory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RewardCategory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RewardCategory_relational_fields:
                        raise errors.UnknownRelationalFieldError('RewardCategory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RewardCategory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RewardCategory',
            }
        )
        _created_partial_types.add(name)


class RewardCatalog(bases.BaseRewardCatalog):
    """Represents a RewardCatalog record"""

    id: _str
    rewardName: _str
    rewardCode: _str
    description: Optional[_str] = None
    defaultPoints: _int
    categoryId: _str
    minPoints: _int
    maxPoints: _int
    isActive: _bool
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    category: Optional['models.RewardCategory'] = None
    createdByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    rewardHistory: Optional[List['models.RewardHistory']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RewardCatalogKeys']] = None,
        exclude: Optional[Iterable['types.RewardCatalogKeys']] = None,
        required: Optional[Iterable['types.RewardCatalogKeys']] = None,
        optional: Optional[Iterable['types.RewardCatalogKeys']] = None,
        relations: Optional[Mapping['types.RewardCatalogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RewardCatalogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RewardCatalog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RewardCatalog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RewardCatalog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RewardCatalog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RewardCatalog_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RewardCatalog_relational_fields:
                        raise errors.UnknownRelationalFieldError('RewardCatalog', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RewardCatalog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RewardCatalog',
            }
        )
        _created_partial_types.add(name)


class Employee(bases.BaseEmployee):
    """Represents a Employee record"""

    id: _str
    username: _str
    email: _str
    designationId: _str
    passwordHash: _str
    departmentId: _str
    managerId: Optional[_str] = None
    dateOfJoining: datetime.datetime
    statusId: _str
    createdAt: datetime.datetime
    createdBy: Optional[_str] = None
    updatedAt: datetime.datetime
    updatedBy: Optional[_str] = None
    auditLogs: Optional[List['models.AuditLog']] = None
    createdDepartmentTypes: Optional[List['models.DepartmentType']] = None
    updatedDepartmentTypes: Optional[List['models.DepartmentType']] = None
    createdDepartments: Optional[List['models.Department']] = None
    updatedDepartments: Optional[List['models.Department']] = None
    createdDesignations: Optional[List['models.Designation']] = None
    updatedDesignations: Optional[List['models.Designation']] = None
    assignedEmployeeRoles: Optional[List['models.EmployeeRole']] = None
    createdEmployeeRoles: Optional[List['models.EmployeeRole']] = None
    employeeRoles: Optional[List['models.EmployeeRole']] = None
    revokedEmployeeRoles: Optional[List['models.EmployeeRole']] = None
    updatedEmployeeRoles: Optional[List['models.EmployeeRole']] = None
    creator: Optional['models.Employee'] = None
    createdEmployees: Optional[List['models.Employee']] = None
    department: Optional['models.Department'] = None
    designation: Optional['models.Designation'] = None
    manager: Optional['models.Employee'] = None
    subordinates: Optional[List['models.Employee']] = None
    status: Optional['models.StatusMaster'] = None
    updater: Optional['models.Employee'] = None
    updatedEmployees: Optional[List['models.Employee']] = None
    refresh_tokens: Optional[List['models.refresh_tokens']] = None
    createdReviews: Optional[List['models.Review']] = None
    reviewsReceived: Optional[List['models.Review']] = None
    reviewsGiven: Optional[List['models.Review']] = None
    updatedReviews: Optional[List['models.Review']] = None
    createdRewardCatalogs: Optional[List['models.RewardCatalog']] = None
    updatedRewardCatalogs: Optional[List['models.RewardCatalog']] = None
    createdRewardCategories: Optional[List['models.RewardCategory']] = None
    updatedRewardCategories: Optional[List['models.RewardCategory']] = None
    createdRewardHistory: Optional[List['models.RewardHistory']] = None
    rewardsGranted: Optional[List['models.RewardHistory']] = None
    updatedRewardHistory: Optional[List['models.RewardHistory']] = None
    createdRoles: Optional[List['models.Role']] = None
    updatedRoles: Optional[List['models.Role']] = None
    createdStatuses: Optional[List['models.StatusMaster']] = None
    updatedStatuses: Optional[List['models.StatusMaster']] = None
    createdTransactionTypes: Optional[List['models.TransactionType']] = None
    updatedTransactionTypes: Optional[List['models.TransactionType']] = None
    createdTransactions: Optional[List['models.Transaction']] = None
    updatedTransactions: Optional[List['models.Transaction']] = None
    createdWallets: Optional[List['models.Wallet']] = None
    wallet: Optional['models.Wallet'] = None
    updatedWallets: Optional[List['models.Wallet']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmployeeKeys']] = None,
        exclude: Optional[Iterable['types.EmployeeKeys']] = None,
        required: Optional[Iterable['types.EmployeeKeys']] = None,
        optional: Optional[Iterable['types.EmployeeKeys']] = None,
        relations: Optional[Mapping['types.EmployeeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmployeeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Employee_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Employee_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Employee_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Employee_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Employee_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Employee_relational_fields:
                        raise errors.UnknownRelationalFieldError('Employee', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Employee / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Employee',
            }
        )
        _created_partial_types.add(name)


class EmployeeRole(bases.BaseEmployeeRole):
    """Represents a EmployeeRole record"""

    id: _str
    employeeId: _str
    roleId: _str
    assignedAt: datetime.datetime
    assignedBy: _str
    revokedAt: Optional[datetime.datetime] = None
    revokedBy: Optional[_str] = None
    isActive: _bool
    createdAt: datetime.datetime
    createdBy: _str
    updatedAt: datetime.datetime
    updatedBy: _str
    assignedByEmployee: Optional['models.Employee'] = None
    createdByEmployee: Optional['models.Employee'] = None
    employee: Optional['models.Employee'] = None
    revokedByEmployee: Optional['models.Employee'] = None
    role: Optional['models.Role'] = None
    updatedByEmployee: Optional['models.Employee'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmployeeRoleKeys']] = None,
        exclude: Optional[Iterable['types.EmployeeRoleKeys']] = None,
        required: Optional[Iterable['types.EmployeeRoleKeys']] = None,
        optional: Optional[Iterable['types.EmployeeRoleKeys']] = None,
        relations: Optional[Mapping['types.EmployeeRoleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmployeeRoleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmployeeRole_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmployeeRole_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmployeeRole_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmployeeRole_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmployeeRole_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmployeeRole_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmployeeRole', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmployeeRole / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmployeeRole',
            }
        )
        _created_partial_types.add(name)


class Wallet(bases.BaseWallet):
    """Represents a Wallet record"""

    id: _str
    employeeId: _str
    availablePoints: _int
    redeemedPoints: _int
    totalEarnedPoints: _int
    version: _int
    createdAt: datetime.datetime
    createdBy: _str
    updatedAt: datetime.datetime
    updatedBy: _str
    rewardHistory: Optional[List['models.RewardHistory']] = None
    transactions: Optional[List['models.Transaction']] = None
    createdByEmployee: Optional['models.Employee'] = None
    employee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WalletKeys']] = None,
        exclude: Optional[Iterable['types.WalletKeys']] = None,
        required: Optional[Iterable['types.WalletKeys']] = None,
        optional: Optional[Iterable['types.WalletKeys']] = None,
        relations: Optional[Mapping['types.WalletRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WalletKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Wallet_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Wallet_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Wallet_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Wallet_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Wallet_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Wallet_relational_fields:
                        raise errors.UnknownRelationalFieldError('Wallet', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Wallet / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Wallet',
            }
        )
        _created_partial_types.add(name)


class Transaction(bases.BaseTransaction):
    """Represents a Transaction record"""

    id: _str
    walletId: _str
    amount: _int
    transactionTypeId: _str
    statusId: _str
    description: Optional[_str] = None
    referenceNumber: _str
    transactionAt: datetime.datetime
    createdAt: datetime.datetime
    createdBy: _str
    updatedAt: datetime.datetime
    updatedBy: _str
    createdByEmployee: Optional['models.Employee'] = None
    status: Optional['models.StatusMaster'] = None
    transactionType: Optional['models.TransactionType'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    wallet: Optional['models.Wallet'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TransactionKeys']] = None,
        exclude: Optional[Iterable['types.TransactionKeys']] = None,
        required: Optional[Iterable['types.TransactionKeys']] = None,
        optional: Optional[Iterable['types.TransactionKeys']] = None,
        relations: Optional[Mapping['types.TransactionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TransactionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Transaction_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Transaction_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Transaction_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Transaction_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Transaction_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Transaction_relational_fields:
                        raise errors.UnknownRelationalFieldError('Transaction', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Transaction / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Transaction',
            }
        )
        _created_partial_types.add(name)


class RewardHistory(bases.BaseRewardHistory):
    """Represents a RewardHistory record"""

    id: _str
    walletId: _str
    catalogId: _str
    grantedBy: _str
    points: _int
    comment: Optional[_str] = None
    grantedAt: datetime.datetime
    createdAt: datetime.datetime
    createdBy: _str
    updatedAt: datetime.datetime
    updatedBy: _str
    catalog: Optional['models.RewardCatalog'] = None
    createdByEmployee: Optional['models.Employee'] = None
    grantedByEmployee: Optional['models.Employee'] = None
    updatedByEmployee: Optional['models.Employee'] = None
    wallet: Optional['models.Wallet'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RewardHistoryKeys']] = None,
        exclude: Optional[Iterable['types.RewardHistoryKeys']] = None,
        required: Optional[Iterable['types.RewardHistoryKeys']] = None,
        optional: Optional[Iterable['types.RewardHistoryKeys']] = None,
        relations: Optional[Mapping['types.RewardHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RewardHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RewardHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RewardHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RewardHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RewardHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _RewardHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _RewardHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('RewardHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RewardHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RewardHistory',
            }
        )
        _created_partial_types.add(name)


class Review(bases.BaseReview):
    """Represents a Review record"""

    id: _str
    reviewerId: _str
    receiverId: _str
    rating: _int
    comment: _str
    imageUrl: Optional[_str] = None
    videoUrl: Optional[_str] = None
    statusId: _str
    reviewAt: datetime.datetime
    createdAt: datetime.datetime
    createdBy: _str
    updatedAt: datetime.datetime
    updatedBy: _str
    createdByEmployee: Optional['models.Employee'] = None
    receiver: Optional['models.Employee'] = None
    reviewer: Optional['models.Employee'] = None
    status: Optional['models.StatusMaster'] = None
    updatedByEmployee: Optional['models.Employee'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ReviewKeys']] = None,
        exclude: Optional[Iterable['types.ReviewKeys']] = None,
        required: Optional[Iterable['types.ReviewKeys']] = None,
        optional: Optional[Iterable['types.ReviewKeys']] = None,
        relations: Optional[Mapping['types.ReviewRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ReviewKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Review_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Review_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Review_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Review_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Review_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Review_relational_fields:
                        raise errors.UnknownRelationalFieldError('Review', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Review / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Review',
            }
        )
        _created_partial_types.add(name)


class AuditLog(bases.BaseAuditLog):
    """Represents a AuditLog record"""

    id: _str
    tableName: _str
    recordId: _str
    operationType: _str
    oldValues: Optional['fields.Json'] = None
    newValues: Optional['fields.Json'] = None
    performedBy: _str
    performedAt: datetime.datetime
    ipAddress: Optional[_str] = None
    userAgent: Optional[_str] = None
    performedByEmployee: Optional['models.Employee'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AuditLogKeys']] = None,
        exclude: Optional[Iterable['types.AuditLogKeys']] = None,
        required: Optional[Iterable['types.AuditLogKeys']] = None,
        optional: Optional[Iterable['types.AuditLogKeys']] = None,
        relations: Optional[Mapping['types.AuditLogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AuditLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AuditLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AuditLog_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AuditLog_relational_fields:
                        raise errors.UnknownRelationalFieldError('AuditLog', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AuditLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AuditLog',
            }
        )
        _created_partial_types.add(name)


class refresh_tokens(bases.Baserefresh_tokens):
    """Represents a refresh_tokens record"""

    token_id: _str
    token_hash: _str
    employee_id: _str
    expires_at: datetime.datetime
    revoked_at: Optional[datetime.datetime] = None
    replaced_by_token: Optional[_str] = None
    created_at: datetime.datetime
    updated_at: datetime.datetime
    employees: Optional['models.Employee'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.refresh_tokensKeys']] = None,
        exclude: Optional[Iterable['types.refresh_tokensKeys']] = None,
        required: Optional[Iterable['types.refresh_tokensKeys']] = None,
        optional: Optional[Iterable['types.refresh_tokensKeys']] = None,
        relations: Optional[Mapping['types.refresh_tokensRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.refresh_tokensKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _refresh_tokens_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _refresh_tokens_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _refresh_tokens_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _refresh_tokens_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _refresh_tokens_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _refresh_tokens_relational_fields:
                        raise errors.UnknownRelationalFieldError('refresh_tokens', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid refresh_tokens / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'refresh_tokens',
            }
        )
        _created_partial_types.add(name)



_StatusMaster_relational_fields: Set[str] = {
        'employees',
        'reviews',
        'createdByEmployee',
        'updatedByEmployee',
        'transactions',
    }
_StatusMaster_fields: Dict['types.StatusMasterKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('statusCode', {
            'name': 'statusCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('statusName', {
            'name': 'statusName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('entityType', {
            'name': 'entityType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employees', {
            'name': 'employees',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Employee\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviews', {
            'name': 'reviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Designation_relational_fields: Set[str] = {
        'createdByEmployee',
        'updatedByEmployee',
        'employees',
    }
_Designation_fields: Dict['types.DesignationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('designationName', {
            'name': 'designationName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('designationCode', {
            'name': 'designationCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('level', {
            'name': 'level',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('employees', {
            'name': 'employees',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Employee\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_DepartmentType_relational_fields: Set[str] = {
        'createdByEmployee',
        'updatedByEmployee',
        'departments',
    }
_DepartmentType_fields: Dict['types.DepartmentTypeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('typeName', {
            'name': 'typeName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('typeCode', {
            'name': 'typeCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('departments', {
            'name': 'departments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Department\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Department_relational_fields: Set[str] = {
        'createdByEmployee',
        'departmentType',
        'updatedByEmployee',
        'employees',
    }
_Department_fields: Dict['types.DepartmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('departmentName', {
            'name': 'departmentName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('departmentCode', {
            'name': 'departmentCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('departmentTypeId', {
            'name': 'departmentTypeId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('departmentType', {
            'name': 'departmentType',
            'is_list': False,
            'optional': True,
            'type': 'models.DepartmentType',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('employees', {
            'name': 'employees',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Employee\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Role_relational_fields: Set[str] = {
        'employeeRoles',
        'createdByEmployee',
        'updatedByEmployee',
    }
_Role_fields: Dict['types.RoleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('roleName', {
            'name': 'roleName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('roleCode', {
            'name': 'roleCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeRoles', {
            'name': 'employeeRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmployeeRole\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_TransactionType_relational_fields: Set[str] = {
        'createdByEmployee',
        'updatedByEmployee',
        'transactions',
    }
_TransactionType_fields: Dict['types.TransactionTypeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('typeName', {
            'name': 'typeName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('typeCode', {
            'name': 'typeCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isCredit', {
            'name': 'isCredit',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_RewardCategory_relational_fields: Set[str] = {
        'rewardCatalog',
        'createdByEmployee',
        'updatedByEmployee',
    }
_RewardCategory_fields: Dict['types.RewardCategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryName', {
            'name': 'categoryName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryCode', {
            'name': 'categoryCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rewardCatalog', {
            'name': 'rewardCatalog',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardCatalog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_RewardCatalog_relational_fields: Set[str] = {
        'category',
        'createdByEmployee',
        'updatedByEmployee',
        'rewardHistory',
    }
_RewardCatalog_fields: Dict['types.RewardCatalogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rewardName', {
            'name': 'rewardName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rewardCode', {
            'name': 'rewardCode',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('defaultPoints', {
            'name': 'defaultPoints',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('categoryId', {
            'name': 'categoryId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('minPoints', {
            'name': 'minPoints',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('maxPoints', {
            'name': 'maxPoints',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.RewardCategory',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('rewardHistory', {
            'name': 'rewardHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Employee_relational_fields: Set[str] = {
        'auditLogs',
        'createdDepartmentTypes',
        'updatedDepartmentTypes',
        'createdDepartments',
        'updatedDepartments',
        'createdDesignations',
        'updatedDesignations',
        'assignedEmployeeRoles',
        'createdEmployeeRoles',
        'employeeRoles',
        'revokedEmployeeRoles',
        'updatedEmployeeRoles',
        'creator',
        'createdEmployees',
        'department',
        'designation',
        'manager',
        'subordinates',
        'status',
        'updater',
        'updatedEmployees',
        'refresh_tokens',
        'createdReviews',
        'reviewsReceived',
        'reviewsGiven',
        'updatedReviews',
        'createdRewardCatalogs',
        'updatedRewardCatalogs',
        'createdRewardCategories',
        'updatedRewardCategories',
        'createdRewardHistory',
        'rewardsGranted',
        'updatedRewardHistory',
        'createdRoles',
        'updatedRoles',
        'createdStatuses',
        'updatedStatuses',
        'createdTransactionTypes',
        'updatedTransactionTypes',
        'createdTransactions',
        'updatedTransactions',
        'createdWallets',
        'wallet',
        'updatedWallets',
    }
_Employee_fields: Dict['types.EmployeeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('designationId', {
            'name': 'designationId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('passwordHash', {
            'name': 'passwordHash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('departmentId', {
            'name': 'departmentId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('managerId', {
            'name': 'managerId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dateOfJoining', {
            'name': 'dateOfJoining',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('statusId', {
            'name': 'statusId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('auditLogs', {
            'name': 'auditLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AuditLog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdDepartmentTypes', {
            'name': 'createdDepartmentTypes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DepartmentType\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedDepartmentTypes', {
            'name': 'updatedDepartmentTypes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DepartmentType\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdDepartments', {
            'name': 'createdDepartments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Department\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedDepartments', {
            'name': 'updatedDepartments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Department\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdDesignations', {
            'name': 'createdDesignations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Designation\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedDesignations', {
            'name': 'updatedDesignations',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Designation\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('assignedEmployeeRoles', {
            'name': 'assignedEmployeeRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmployeeRole\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdEmployeeRoles', {
            'name': 'createdEmployeeRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmployeeRole\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('employeeRoles', {
            'name': 'employeeRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmployeeRole\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('revokedEmployeeRoles', {
            'name': 'revokedEmployeeRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmployeeRole\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedEmployeeRoles', {
            'name': 'updatedEmployeeRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmployeeRole\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('creator', {
            'name': 'creator',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdEmployees', {
            'name': 'createdEmployees',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Employee\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('department', {
            'name': 'department',
            'is_list': False,
            'optional': True,
            'type': 'models.Department',
            'is_relational': True,
            'documentation': None,
        }),
        ('designation', {
            'name': 'designation',
            'is_list': False,
            'optional': True,
            'type': 'models.Designation',
            'is_relational': True,
            'documentation': None,
        }),
        ('manager', {
            'name': 'manager',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('subordinates', {
            'name': 'subordinates',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Employee\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': 'models.StatusMaster',
            'is_relational': True,
            'documentation': None,
        }),
        ('updater', {
            'name': 'updater',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedEmployees', {
            'name': 'updatedEmployees',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Employee\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('refresh_tokens', {
            'name': 'refresh_tokens',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.refresh_tokens\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdReviews', {
            'name': 'createdReviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviewsReceived', {
            'name': 'reviewsReceived',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviewsGiven', {
            'name': 'reviewsGiven',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedReviews', {
            'name': 'updatedReviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdRewardCatalogs', {
            'name': 'createdRewardCatalogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardCatalog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedRewardCatalogs', {
            'name': 'updatedRewardCatalogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardCatalog\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdRewardCategories', {
            'name': 'createdRewardCategories',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardCategory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedRewardCategories', {
            'name': 'updatedRewardCategories',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardCategory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdRewardHistory', {
            'name': 'createdRewardHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rewardsGranted', {
            'name': 'rewardsGranted',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedRewardHistory', {
            'name': 'updatedRewardHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdRoles', {
            'name': 'createdRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Role\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedRoles', {
            'name': 'updatedRoles',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Role\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdStatuses', {
            'name': 'createdStatuses',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StatusMaster\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedStatuses', {
            'name': 'updatedStatuses',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.StatusMaster\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdTransactionTypes', {
            'name': 'createdTransactionTypes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TransactionType\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedTransactionTypes', {
            'name': 'updatedTransactionTypes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TransactionType\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdTransactions', {
            'name': 'createdTransactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedTransactions', {
            'name': 'updatedTransactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdWallets', {
            'name': 'createdWallets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Wallet\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('wallet', {
            'name': 'wallet',
            'is_list': False,
            'optional': True,
            'type': 'models.Wallet',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedWallets', {
            'name': 'updatedWallets',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Wallet\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_EmployeeRole_relational_fields: Set[str] = {
        'assignedByEmployee',
        'createdByEmployee',
        'employee',
        'revokedByEmployee',
        'role',
        'updatedByEmployee',
    }
_EmployeeRole_fields: Dict['types.EmployeeRoleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeId', {
            'name': 'employeeId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('roleId', {
            'name': 'roleId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedAt', {
            'name': 'assignedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedBy', {
            'name': 'assignedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('revokedAt', {
            'name': 'revokedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('revokedBy', {
            'name': 'revokedBy',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('assignedByEmployee', {
            'name': 'assignedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('employee', {
            'name': 'employee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('revokedByEmployee', {
            'name': 'revokedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': True,
            'type': 'models.Role',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Wallet_relational_fields: Set[str] = {
        'rewardHistory',
        'transactions',
        'createdByEmployee',
        'employee',
        'updatedByEmployee',
    }
_Wallet_fields: Dict['types.WalletKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employeeId', {
            'name': 'employeeId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('availablePoints', {
            'name': 'availablePoints',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('redeemedPoints', {
            'name': 'redeemedPoints',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalEarnedPoints', {
            'name': 'totalEarnedPoints',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('version', {
            'name': 'version',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rewardHistory', {
            'name': 'rewardHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.RewardHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactions', {
            'name': 'transactions',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Transaction\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('employee', {
            'name': 'employee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Transaction_relational_fields: Set[str] = {
        'createdByEmployee',
        'status',
        'transactionType',
        'updatedByEmployee',
        'wallet',
    }
_Transaction_fields: Dict['types.TransactionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('walletId', {
            'name': 'walletId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('transactionTypeId', {
            'name': 'transactionTypeId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('statusId', {
            'name': 'statusId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('referenceNumber', {
            'name': 'referenceNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('transactionAt', {
            'name': 'transactionAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': 'models.StatusMaster',
            'is_relational': True,
            'documentation': None,
        }),
        ('transactionType', {
            'name': 'transactionType',
            'is_list': False,
            'optional': True,
            'type': 'models.TransactionType',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('wallet', {
            'name': 'wallet',
            'is_list': False,
            'optional': True,
            'type': 'models.Wallet',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_RewardHistory_relational_fields: Set[str] = {
        'catalog',
        'createdByEmployee',
        'grantedByEmployee',
        'updatedByEmployee',
        'wallet',
    }
_RewardHistory_fields: Dict['types.RewardHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('walletId', {
            'name': 'walletId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('catalogId', {
            'name': 'catalogId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('grantedBy', {
            'name': 'grantedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('points', {
            'name': 'points',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('comment', {
            'name': 'comment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('grantedAt', {
            'name': 'grantedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('catalog', {
            'name': 'catalog',
            'is_list': False,
            'optional': True,
            'type': 'models.RewardCatalog',
            'is_relational': True,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('grantedByEmployee', {
            'name': 'grantedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('wallet', {
            'name': 'wallet',
            'is_list': False,
            'optional': True,
            'type': 'models.Wallet',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Review_relational_fields: Set[str] = {
        'createdByEmployee',
        'receiver',
        'reviewer',
        'status',
        'updatedByEmployee',
    }
_Review_fields: Dict['types.ReviewKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reviewerId', {
            'name': 'reviewerId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('receiverId', {
            'name': 'receiverId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('comment', {
            'name': 'comment',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('imageUrl', {
            'name': 'imageUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('videoUrl', {
            'name': 'videoUrl',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('statusId', {
            'name': 'statusId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('reviewAt', {
            'name': 'reviewAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdBy', {
            'name': 'createdBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedBy', {
            'name': 'updatedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdByEmployee', {
            'name': 'createdByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('receiver', {
            'name': 'receiver',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviewer', {
            'name': 'reviewer',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': True,
            'type': 'models.StatusMaster',
            'is_relational': True,
            'documentation': None,
        }),
        ('updatedByEmployee', {
            'name': 'updatedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AuditLog_relational_fields: Set[str] = {
        'performedByEmployee',
    }
_AuditLog_fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tableName', {
            'name': 'tableName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('recordId', {
            'name': 'recordId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('operationType', {
            'name': 'operationType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('oldValues', {
            'name': 'oldValues',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('newValues', {
            'name': 'newValues',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('performedBy', {
            'name': 'performedBy',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('performedAt', {
            'name': 'performedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ipAddress', {
            'name': 'ipAddress',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userAgent', {
            'name': 'userAgent',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('performedByEmployee', {
            'name': 'performedByEmployee',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_refresh_tokens_relational_fields: Set[str] = {
        'employees',
    }
_refresh_tokens_fields: Dict['types.refresh_tokensKeys', PartialModelField] = OrderedDict(
    [
        ('token_id', {
            'name': 'token_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('token_hash', {
            'name': 'token_hash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('employee_id', {
            'name': 'employee_id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('expires_at', {
            'name': 'expires_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('revoked_at', {
            'name': 'revoked_at',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('replaced_by_token', {
            'name': 'replaced_by_token',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('created_at', {
            'name': 'created_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updated_at', {
            'name': 'updated_at',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('employees', {
            'name': 'employees',
            'is_list': False,
            'optional': True,
            'type': 'models.Employee',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(StatusMaster)
model_rebuild(Designation)
model_rebuild(DepartmentType)
model_rebuild(Department)
model_rebuild(Role)
model_rebuild(TransactionType)
model_rebuild(RewardCategory)
model_rebuild(RewardCatalog)
model_rebuild(Employee)
model_rebuild(EmployeeRole)
model_rebuild(Wallet)
model_rebuild(Transaction)
model_rebuild(RewardHistory)
model_rebuild(Review)
model_rebuild(AuditLog)
model_rebuild(refresh_tokens)
